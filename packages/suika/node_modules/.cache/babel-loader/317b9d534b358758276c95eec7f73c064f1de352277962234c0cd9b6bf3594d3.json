{"ast":null,"code":"var _jsxFileName = \"/Users/yangdan/zf-workspace/react/suika/packages/suika/src/components/input/ColorHexInput.tsx\",\n  _s = $RefreshSig$();\nimport { useEffect, useRef } from 'react';\nimport CustomRuleInput from './CustomRuleInput';\nimport { normalizeHex } from '../../utils/color';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ColorHexInput = ({\n  value,\n  onBlur,\n  prefix\n}) => {\n  _s();\n  const inputRef = useRef(null);\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.value = String(value);\n    }\n  }, [value]);\n  return /*#__PURE__*/_jsxDEV(CustomRuleInput, {\n    prefix: prefix,\n    parser: (str, prevStr) => {\n      str = str.trim();\n      // check if it is a valid hex and normalize it\n      str = normalizeHex(str);\n      if (!str || str === prevStr) {\n        return false;\n      }\n      return str;\n    },\n    value: value,\n    onBlur: newVal => onBlur(newVal)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 21,\n    columnNumber: 5\n  }, this);\n};\n_s(ColorHexInput, \"cBQ6FQ+sf5H+lvNONLKqtm4aeQ8=\");\n_c = ColorHexInput;\nvar _c;\n$RefreshReg$(_c, \"ColorHexInput\");","map":{"version":3,"names":["useEffect","useRef","CustomRuleInput","normalizeHex","jsxDEV","_jsxDEV","ColorHexInput","value","onBlur","prefix","_s","inputRef","current","String","parser","str","prevStr","trim","newVal","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/yangdan/zf-workspace/react/suika/packages/suika/src/components/input/ColorHexInput.tsx"],"sourcesContent":["import { FC, useEffect, useRef } from 'react';\nimport CustomRuleInput from './CustomRuleInput';\nimport { normalizeHex } from '../../utils/color';\n\ninterface IProps {\n  value: string;\n  onBlur: (newValue: string) => void;\n  prefix?: React.ReactNode;\n}\n\nexport const ColorHexInput: FC<IProps> = ({ value, onBlur, prefix }) => {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.value = String(value);\n    }\n  }, [value]);\n\n  return (\n    <CustomRuleInput\n      prefix={prefix}\n      parser={(str, prevStr) => {\n        str = str.trim();\n        // check if it is a valid hex and normalize it\n        str = normalizeHex(str);\n        if (!str || str === prevStr) {\n          return false;\n        }\n        return str;\n      }}\n      value={value}\n      onBlur={(newVal) => onBlur(newVal)}\n    />\n  );\n};\n"],"mappings":";;AAAA,SAAaA,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAC7C,OAAOC,eAAe,MAAM,mBAAmB;AAC/C,SAASC,YAAY,QAAQ,mBAAmB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAQjD,OAAO,MAAMC,aAAyB,GAAGA,CAAC;EAAEC,KAAK;EAAEC,MAAM;EAAEC;AAAO,CAAC,KAAK;EAAAC,EAAA;EACtE,MAAMC,QAAQ,GAAGV,MAAM,CAAmB,IAAI,CAAC;EAE/CD,SAAS,CAAC,MAAM;IACd,IAAIW,QAAQ,CAACC,OAAO,EAAE;MACpBD,QAAQ,CAACC,OAAO,CAACL,KAAK,GAAGM,MAAM,CAACN,KAAK,CAAC;IACxC;EACF,CAAC,EAAE,CAACA,KAAK,CAAC,CAAC;EAEX,oBACEF,OAAA,CAACH,eAAe;IACdO,MAAM,EAAEA,MAAO;IACfK,MAAM,EAAEA,CAACC,GAAG,EAAEC,OAAO,KAAK;MACxBD,GAAG,GAAGA,GAAG,CAACE,IAAI,CAAC,CAAC;MAChB;MACAF,GAAG,GAAGZ,YAAY,CAACY,GAAG,CAAC;MACvB,IAAI,CAACA,GAAG,IAAIA,GAAG,KAAKC,OAAO,EAAE;QAC3B,OAAO,KAAK;MACd;MACA,OAAOD,GAAG;IACZ,CAAE;IACFR,KAAK,EAAEA,KAAM;IACbC,MAAM,EAAGU,MAAM,IAAKV,MAAM,CAACU,MAAM;EAAE;IAAAC,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACpC,CAAC;AAEN,CAAC;AAACZ,EAAA,CAzBWJ,aAAyB;AAAAiB,EAAA,GAAzBjB,aAAyB;AAAA,IAAAiB,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}