{"ast":null,"code":"export class RemoveElement {\n  constructor(desc, editor, removedElements) {\n    this.desc = desc;\n    this.editor = editor;\n    this.removedElements = removedElements;\n    this.removedIndexes = [];\n    this.do();\n  }\n  do() {\n    this.removedIndexes = [];\n    const set = new Set(this.removedElements);\n    if (set.size !== this.removedElements.length) {\n      throw new Error('removedElements 不能有重复元素');\n    }\n    const sceneGraph = this.editor.sceneGraph;\n    const nextElements = [];\n    const elements = sceneGraph.children;\n    for (let i = 0, len = elements.length; i < len; i++) {\n      const element = elements[i];\n      if (set.has(element)) {\n        this.removedIndexes.push(i);\n      } else {\n        nextElements.push(element);\n      }\n    }\n    sceneGraph.children = nextElements;\n    this.editor.selectedElements.clear();\n  }\n  redo() {\n    this.do();\n  }\n  undo() {\n    // 实现上有点复杂了...如果是链表会简单一些，以后还是考虑换成链表实现图形树\n    const sceneGraph = this.editor.sceneGraph;\n    const removedElements = this.removedElements;\n    const elements = sceneGraph.children;\n    const removedIndexes = this.removedIndexes;\n    const nextElements = new Array(elements.length + removedIndexes.length);\n    let i = 0; // nextElements 的指针\n    let j = 0; // elements\n    let k = 0; // removedIndexes 和 removedElement 的指针\n    while (i < nextElements.length) {\n      if (i === removedIndexes[k]) {\n        nextElements[i] = removedElements[k];\n        k++;\n      } else {\n        nextElements[i] = elements[j];\n        j++;\n      }\n      i++;\n    }\n    sceneGraph.children = nextElements;\n    this.editor.selectedElements.setItems(removedElements);\n  }\n}","map":{"version":3,"names":["RemoveElement","constructor","desc","editor","removedElements","removedIndexes","do","set","Set","size","length","Error","sceneGraph","nextElements","elements","children","i","len","element","has","push","selectedElements","clear","redo","undo","Array","j","k","setItems"],"sources":["/Users/yangdan/zf-workspace/react/suika/packages/suika/src/editor/commands/remove_element.ts"],"sourcesContent":["import { Graph } from '../scene/graph';\nimport { Editor } from '../editor';\nimport { ICommand } from './type';\n\nexport class RemoveElement implements ICommand {\n  private removedIndexes: number[] = [];\n\n  constructor(\n    public desc: string,\n    private editor: Editor,\n    private removedElements: Graph[],\n  ) {\n    this.do();\n  }\n  private do() {\n    this.removedIndexes = [];\n    const set = new Set(this.removedElements);\n    if (set.size !== this.removedElements.length) {\n      throw new Error('removedElements 不能有重复元素');\n    }\n    const sceneGraph = this.editor.sceneGraph;\n    const nextElements: Graph[] = [];\n    const elements = sceneGraph.children;\n    for (let i = 0, len = elements.length; i < len; i++) {\n      const element = elements[i];\n      if (set.has(element)) {\n        this.removedIndexes.push(i);\n      } else {\n        nextElements.push(element);\n      }\n    }\n    sceneGraph.children = nextElements;\n\n    this.editor.selectedElements.clear();\n  }\n  redo() {\n    this.do();\n  }\n  undo() {\n    // 实现上有点复杂了...如果是链表会简单一些，以后还是考虑换成链表实现图形树\n    const sceneGraph = this.editor.sceneGraph;\n    const removedElements = this.removedElements;\n    const elements = sceneGraph.children;\n    const removedIndexes = this.removedIndexes;\n    const nextElements: Graph[] = new Array(\n      elements.length + removedIndexes.length,\n    );\n\n    let i = 0; // nextElements 的指针\n    let j = 0; // elements\n    let k = 0; // removedIndexes 和 removedElement 的指针\n    while (i < nextElements.length) {\n      if (i === removedIndexes[k]) {\n        nextElements[i] = removedElements[k];\n        k++;\n      } else {\n        nextElements[i] = elements[j];\n        j++;\n      }\n      i++;\n    }\n    sceneGraph.children = nextElements;\n\n    this.editor.selectedElements.setItems(removedElements);\n  }\n}\n"],"mappings":"AAIA,OAAO,MAAMA,aAAa,CAAqB;EAG7CC,WAAWA,CACFC,IAAY,EACXC,MAAc,EACdC,eAAwB,EAChC;IAAA,KAHOF,IAAY,GAAZA,IAAY;IAAA,KACXC,MAAc,GAAdA,MAAc;IAAA,KACdC,eAAwB,GAAxBA,eAAwB;IAAA,KAL1BC,cAAc,GAAa,EAAE;IAOnC,IAAI,CAACC,EAAE,CAAC,CAAC;EACX;EACQA,EAAEA,CAAA,EAAG;IACX,IAAI,CAACD,cAAc,GAAG,EAAE;IACxB,MAAME,GAAG,GAAG,IAAIC,GAAG,CAAC,IAAI,CAACJ,eAAe,CAAC;IACzC,IAAIG,GAAG,CAACE,IAAI,KAAK,IAAI,CAACL,eAAe,CAACM,MAAM,EAAE;MAC5C,MAAM,IAAIC,KAAK,CAAC,yBAAyB,CAAC;IAC5C;IACA,MAAMC,UAAU,GAAG,IAAI,CAACT,MAAM,CAACS,UAAU;IACzC,MAAMC,YAAqB,GAAG,EAAE;IAChC,MAAMC,QAAQ,GAAGF,UAAU,CAACG,QAAQ;IACpC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,QAAQ,CAACJ,MAAM,EAAEM,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAME,OAAO,GAAGJ,QAAQ,CAACE,CAAC,CAAC;MAC3B,IAAIT,GAAG,CAACY,GAAG,CAACD,OAAO,CAAC,EAAE;QACpB,IAAI,CAACb,cAAc,CAACe,IAAI,CAACJ,CAAC,CAAC;MAC7B,CAAC,MAAM;QACLH,YAAY,CAACO,IAAI,CAACF,OAAO,CAAC;MAC5B;IACF;IACAN,UAAU,CAACG,QAAQ,GAAGF,YAAY;IAElC,IAAI,CAACV,MAAM,CAACkB,gBAAgB,CAACC,KAAK,CAAC,CAAC;EACtC;EACAC,IAAIA,CAAA,EAAG;IACL,IAAI,CAACjB,EAAE,CAAC,CAAC;EACX;EACAkB,IAAIA,CAAA,EAAG;IACL;IACA,MAAMZ,UAAU,GAAG,IAAI,CAACT,MAAM,CAACS,UAAU;IACzC,MAAMR,eAAe,GAAG,IAAI,CAACA,eAAe;IAC5C,MAAMU,QAAQ,GAAGF,UAAU,CAACG,QAAQ;IACpC,MAAMV,cAAc,GAAG,IAAI,CAACA,cAAc;IAC1C,MAAMQ,YAAqB,GAAG,IAAIY,KAAK,CACrCX,QAAQ,CAACJ,MAAM,GAAGL,cAAc,CAACK,MACnC,CAAC;IAED,IAAIM,CAAC,GAAG,CAAC,CAAC,CAAC;IACX,IAAIU,CAAC,GAAG,CAAC,CAAC,CAAC;IACX,IAAIC,CAAC,GAAG,CAAC,CAAC,CAAC;IACX,OAAOX,CAAC,GAAGH,YAAY,CAACH,MAAM,EAAE;MAC9B,IAAIM,CAAC,KAAKX,cAAc,CAACsB,CAAC,CAAC,EAAE;QAC3Bd,YAAY,CAACG,CAAC,CAAC,GAAGZ,eAAe,CAACuB,CAAC,CAAC;QACpCA,CAAC,EAAE;MACL,CAAC,MAAM;QACLd,YAAY,CAACG,CAAC,CAAC,GAAGF,QAAQ,CAACY,CAAC,CAAC;QAC7BA,CAAC,EAAE;MACL;MACAV,CAAC,EAAE;IACL;IACAJ,UAAU,CAACG,QAAQ,GAAGF,YAAY;IAElC,IAAI,CAACV,MAAM,CAACkB,gBAAgB,CAACO,QAAQ,CAACxB,eAAe,CAAC;EACxD;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}