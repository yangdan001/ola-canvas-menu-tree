{"ast":null,"code":"import { GraphType } from '../../type';\nimport { rotateInCanvas } from '../../utils/canvas';\nimport { parseRGBAStr } from '../../utils/color';\nimport { TextureType } from '../texture';\nimport { Graph } from './graph';\nexport class Rect extends Graph {\n  constructor(options) {\n    super({\n      ...options,\n      type: GraphType.Rect\n    });\n  }\n  getBBoxWithoutRotation() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  }\n  renderFillAndStrokeTexture(ctx, smooth) {\n    if (this.rotation) {\n      const cx = this.x + this.width / 2;\n      const cy = this.y + this.height / 2;\n      rotateInCanvas(ctx, this.rotation, cx, cy);\n    }\n    ctx.beginPath();\n    ctx.rect(this.x, this.y, this.width, this.height);\n    for (const texture of this.fill) {\n      switch (texture.type) {\n        case TextureType.Solid:\n          {\n            ctx.fillStyle = parseRGBAStr(texture.attrs);\n            ctx.fill();\n            break;\n          }\n        case TextureType.Image:\n          {\n            this.fillImage(ctx, texture, smooth);\n          }\n      }\n    }\n    if (this.strokeWidth) {\n      ctx.lineWidth = this.strokeWidth;\n      for (const texture of this.stroke) {\n        switch (texture.type) {\n          case TextureType.Solid:\n            {\n              ctx.strokeStyle = parseRGBAStr(texture.attrs);\n              ctx.stroke();\n              break;\n            }\n          case TextureType.Image:\n            {\n              // TODO: stroke image\n            }\n        }\n      }\n    }\n    ctx.closePath();\n  }\n}","map":{"version":3,"names":["GraphType","rotateInCanvas","parseRGBAStr","TextureType","Graph","Rect","constructor","options","type","getBBoxWithoutRotation","x","y","width","height","renderFillAndStrokeTexture","ctx","smooth","rotation","cx","cy","beginPath","rect","texture","fill","Solid","fillStyle","attrs","Image","fillImage","strokeWidth","lineWidth","stroke","strokeStyle","closePath"],"sources":["/Users/yangdan/zf-workspace/react/suika/packages/suika/src/editor/scene/rect.ts"],"sourcesContent":["import { GraphType } from '../../type';\nimport { rotateInCanvas } from '../../utils/canvas';\nimport { parseRGBAStr } from '../../utils/color';\nimport { TextureType } from '../texture';\nimport { Graph, GraphAttrs } from './graph';\n\nexport type RectAttrs = GraphAttrs;\n\nexport class Rect extends Graph {\n  constructor(options: RectAttrs) {\n    super({ ...options, type: GraphType.Rect });\n  }\n  getBBoxWithoutRotation() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n    };\n  }\n\n  renderFillAndStrokeTexture(ctx: CanvasRenderingContext2D, smooth: boolean) {\n    if (this.rotation) {\n      const cx = this.x + this.width / 2;\n      const cy = this.y + this.height / 2;\n\n      rotateInCanvas(ctx, this.rotation, cx, cy);\n    }\n    ctx.beginPath();\n    ctx.rect(this.x, this.y, this.width, this.height);\n    for (const texture of this.fill) {\n      switch (texture.type) {\n        case TextureType.Solid: {\n          ctx.fillStyle = parseRGBAStr(texture.attrs);\n          ctx.fill();\n          break;\n        }\n        case TextureType.Image: {\n          this.fillImage(ctx, texture, smooth);\n        }\n      }\n    }\n    if (this.strokeWidth) {\n      ctx.lineWidth = this.strokeWidth;\n      for (const texture of this.stroke) {\n        switch (texture.type) {\n          case TextureType.Solid: {\n            ctx.strokeStyle = parseRGBAStr(texture.attrs);\n            ctx.stroke();\n            break;\n          }\n          case TextureType.Image: {\n            // TODO: stroke image\n          }\n        }\n      }\n    }\n    ctx.closePath();\n  }\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,YAAY;AACtC,SAASC,cAAc,QAAQ,oBAAoB;AACnD,SAASC,YAAY,QAAQ,mBAAmB;AAChD,SAASC,WAAW,QAAQ,YAAY;AACxC,SAASC,KAAK,QAAoB,SAAS;AAI3C,OAAO,MAAMC,IAAI,SAASD,KAAK,CAAC;EAC9BE,WAAWA,CAACC,OAAkB,EAAE;IAC9B,KAAK,CAAC;MAAE,GAAGA,OAAO;MAAEC,IAAI,EAAER,SAAS,CAACK;IAAK,CAAC,CAAC;EAC7C;EACAI,sBAAsBA,CAAA,EAAG;IACvB,OAAO;MACLC,CAAC,EAAE,IAAI,CAACA,CAAC;MACTC,CAAC,EAAE,IAAI,CAACA,CAAC;MACTC,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBC,MAAM,EAAE,IAAI,CAACA;IACf,CAAC;EACH;EAEAC,0BAA0BA,CAACC,GAA6B,EAAEC,MAAe,EAAE;IACzE,IAAI,IAAI,CAACC,QAAQ,EAAE;MACjB,MAAMC,EAAE,GAAG,IAAI,CAACR,CAAC,GAAG,IAAI,CAACE,KAAK,GAAG,CAAC;MAClC,MAAMO,EAAE,GAAG,IAAI,CAACR,CAAC,GAAG,IAAI,CAACE,MAAM,GAAG,CAAC;MAEnCZ,cAAc,CAACc,GAAG,EAAE,IAAI,CAACE,QAAQ,EAAEC,EAAE,EAAEC,EAAE,CAAC;IAC5C;IACAJ,GAAG,CAACK,SAAS,CAAC,CAAC;IACfL,GAAG,CAACM,IAAI,CAAC,IAAI,CAACX,CAAC,EAAE,IAAI,CAACC,CAAC,EAAE,IAAI,CAACC,KAAK,EAAE,IAAI,CAACC,MAAM,CAAC;IACjD,KAAK,MAAMS,OAAO,IAAI,IAAI,CAACC,IAAI,EAAE;MAC/B,QAAQD,OAAO,CAACd,IAAI;QAClB,KAAKL,WAAW,CAACqB,KAAK;UAAE;YACtBT,GAAG,CAACU,SAAS,GAAGvB,YAAY,CAACoB,OAAO,CAACI,KAAK,CAAC;YAC3CX,GAAG,CAACQ,IAAI,CAAC,CAAC;YACV;UACF;QACA,KAAKpB,WAAW,CAACwB,KAAK;UAAE;YACtB,IAAI,CAACC,SAAS,CAACb,GAAG,EAAEO,OAAO,EAAEN,MAAM,CAAC;UACtC;MACF;IACF;IACA,IAAI,IAAI,CAACa,WAAW,EAAE;MACpBd,GAAG,CAACe,SAAS,GAAG,IAAI,CAACD,WAAW;MAChC,KAAK,MAAMP,OAAO,IAAI,IAAI,CAACS,MAAM,EAAE;QACjC,QAAQT,OAAO,CAACd,IAAI;UAClB,KAAKL,WAAW,CAACqB,KAAK;YAAE;cACtBT,GAAG,CAACiB,WAAW,GAAG9B,YAAY,CAACoB,OAAO,CAACI,KAAK,CAAC;cAC7CX,GAAG,CAACgB,MAAM,CAAC,CAAC;cACZ;YACF;UACA,KAAK5B,WAAW,CAACwB,KAAK;YAAE;cACtB;YAAA;QAEJ;MACF;IACF;IACAZ,GAAG,CAACkB,SAAS,CAAC,CAAC;EACjB;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}