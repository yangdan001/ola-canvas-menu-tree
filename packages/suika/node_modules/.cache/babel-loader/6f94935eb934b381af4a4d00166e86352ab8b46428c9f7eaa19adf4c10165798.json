{"ast":null,"code":"import { bboxToBbox2, bboxToBboxWithMid, isRectIntersect2, pointsToHLines, pointsToVLines } from '../utils/graphics';\nimport { getClosestValInSortedArr } from '../utils/common';\nimport { drawLine, drawXShape } from '../utils/canvas';\nimport { arrMap, forEach } from '../utils/array_util';\n\n/**\n * reference line\n */\nexport class RefLine {\n  // 等待绘制的水平参照线\n\n  constructor(editor) {\n    this.editor = editor;\n    /**\n     * 参考图形产生的垂直参照线。对于其中的同一条线，x 相同（作为 key），y 不同（作为 value）\n     */\n    this.vRefLineMap = new Map();\n    /**\n     * 参考图形产生的水平照线，对于其中的同一条线，y 相同（作为 key），x 不同（作为 value）\n     */\n    this.hRefLineMap = new Map();\n    this.sortedXs = [];\n    // 对 vRefLineMap 的 key 排序\n    this.sortedYs = [];\n    // 对 hRefLineMap 的 key 排序\n    this.toDrawVLines = [];\n    // 等待绘制的垂直参照线\n    this.toDrawHLines = [];\n  }\n  cacheXYToBbox() {\n    this.clear();\n    const vRefLineMap = this.vRefLineMap;\n    const hRefLineMap = this.hRefLineMap;\n    const selectIdSet = this.editor.selectedElements.getIdSet();\n    const viewportBbox = this.editor.viewportManager.getBbox2();\n    for (const graph of this.editor.sceneGraph.children) {\n      if (selectIdSet.has(graph.id)) {\n        continue;\n      }\n      const bbox = bboxToBboxWithMid(graph.getBBox2());\n      if (!isRectIntersect2(viewportBbox, bbox)) {\n        continue;\n      }\n\n      // bbox 中水平线\n      this.addBboxToMap(vRefLineMap, bbox.midX, [bbox.minY, bbox.maxY]);\n      // bbox 中垂直线\n      this.addBboxToMap(hRefLineMap, bbox.midY, [bbox.minX, bbox.maxX]);\n\n      /**\n       * 获取旋转后4个顶点的坐标\n       *      top\n       *     /   \\\n       *   /       \\\n       * left      right\n       *   \\       /\n       *    \\    /\n       *    bottom\n       *\n       * special when rotate 90 degree:\n       *\n       * top(left) ---------- right(top)\n       *      |                 |\n       * left(bottom) ------- bottom(right)\n       *\n       * top 和 bottom 要绘制水平参考线，不要绘制垂直参照线\n       * left 和 right 要绘制垂直参照线，不要绘制水平参照线\n       */\n      const bboxVerts = graph.getBboxVerts();\n      const top = bboxVerts.filter(p => p.x === bbox.minX);\n      const bottom = bboxVerts.filter(p => p.x === bbox.maxX);\n      const left = bboxVerts.filter(p => p.y === bbox.minY);\n      const right = bboxVerts.filter(p => p.y === bbox.maxY);\n\n      // top 和 bottom 要绘制水平参考线，不要绘制垂直参照线\n      [...top, ...bottom].forEach(p => {\n        this.addBboxToMap(vRefLineMap, p.x, [p.y]);\n      });\n      // left 和 right 要绘制垂直参照线，不要绘制水平参照线\n      [...left, ...right].forEach(p => {\n        this.addBboxToMap(hRefLineMap, p.y, [p.x]);\n      });\n    }\n    this.sortedXs = Array.from(vRefLineMap.keys()).sort((a, b) => a - b);\n    this.sortedYs = Array.from(hRefLineMap.keys()).sort((a, b) => a - b);\n  }\n  clear() {\n    this.vRefLineMap.clear();\n    this.hRefLineMap.clear();\n    this.sortedXs = [];\n    this.sortedYs = [];\n    this.toDrawVLines = [];\n    this.toDrawHLines = [];\n  }\n  addBboxToMap(m, xOrY, xsOrYs) {\n    const line = m.get(xOrY);\n    if (line) {\n      forEach(xsOrYs, xOrY => {\n        line.add(xOrY);\n      });\n    } else {\n      m.set(xOrY, new Set(xsOrYs));\n    }\n  }\n  getTargetPointFromSelect() {\n    let targetPoints = [];\n    // 选中的为单个图形，要以旋转后的 4 个顶点和中心点为目标线\n    if (this.editor.selectedElements.size() === 1) {\n      const [targetGraph] = this.editor.selectedElements.getItems();\n      targetPoints = [...targetGraph.getBboxVerts(), targetGraph.getCenter()];\n    } else {\n      const targetBbox = bboxToBboxWithMid(bboxToBbox2(this.editor.selectedElements.getBBox()));\n      targetPoints = [{\n        x: targetBbox.minX,\n        y: targetBbox.minY\n      }, {\n        x: targetBbox.minX,\n        y: targetBbox.maxY\n      }, {\n        x: targetBbox.maxX,\n        y: targetBbox.minY\n      }, {\n        x: targetBbox.maxX,\n        y: targetBbox.maxY\n      }, {\n        x: targetBbox.midX,\n        y: targetBbox.midY\n      }];\n    }\n    return targetPoints;\n  }\n\n  /**\n   * update ref line\n   * and return offset\n   */\n  updateRefLine() {\n    var _offsetX2, _offsetY2;\n    const targetPoints = this.getTargetPointFromSelect();\n    this.toDrawVLines = [];\n    this.toDrawHLines = [];\n    let vTargetLines = pointsToVLines(targetPoints); // 目标矩形的垂直线\n    let vTargetLineKeys = Array.from(vTargetLines.keys()); // 目标矩形的垂直线的 x 坐标\n    let hTargetLines = pointsToHLines(targetPoints); // 目标矩形的水平线\n    let hTargetLineKeys = Array.from(hTargetLines.keys()); // 目标矩形的水平线的 y 坐标\n\n    const vRefLineMap = this.vRefLineMap;\n    const hRefLineMap = this.hRefLineMap;\n    const sortedXs = this.sortedXs;\n    const sortedYs = this.sortedYs;\n\n    // there are no reference graphs\n    if (sortedXs.length === 0 && sortedYs.length === 0) {\n      return {\n        offsetX: 0,\n        offsetY: 0\n      };\n    }\n    let offsetX = undefined;\n    let offsetY = undefined;\n    const closestXs = arrMap(vTargetLineKeys, x => getClosestValInSortedArr(sortedXs, x));\n    // 目标矩形的每个 x 坐标离它们最近的参照线的差值\n    const closestXDiffs = arrMap(vTargetLineKeys, (x, i) => closestXs[i] - x);\n    const closestXDist = Math.min(...arrMap(closestXDiffs, item => Math.abs(item)));\n    const closestYs = arrMap(hTargetLineKeys, y => getClosestValInSortedArr(sortedYs, y));\n    // 目标矩形的每个 y 坐标离它们最近的参照线的差值\n    const closestYDiffs = arrMap(hTargetLineKeys, (y, i) => closestYs[i] - y);\n    const closestYDist = Math.min(...arrMap(closestYDiffs, item => Math.abs(item)));\n    const isEqualNum = (a, b) => Math.abs(a - b) < 0.00001;\n    const tol = this.editor.setting.get('refLineTolerance') / this.editor.zoomManager.getZoom();\n\n    // 确定最终偏移值 offsetX\n    if (closestXDist <= tol) {\n      for (let i = 0; i < closestXDiffs.length; i++) {\n        if (isEqualNum(closestXDist, Math.abs(closestXDiffs[i]))) {\n          offsetX = closestXDiffs[i];\n          break;\n        }\n      }\n      if (offsetX === undefined) {\n        throw new Error('it should not reach here, please put a issue to us');\n      }\n    }\n\n    // 再确认偏移值 offsetY\n    if (closestYDist <= tol) {\n      for (let i = 0; i < closestYDiffs.length; i++) {\n        if (isEqualNum(closestYDist, Math.abs(closestYDiffs[i]))) {\n          offsetY = closestYDiffs[i];\n          break;\n        }\n      }\n      if (offsetY === undefined) {\n        throw new Error('it should not reach here, please put a issue to us');\n      }\n    }\n    const correctedTargetPoints = arrMap(targetPoints, p => {\n      var _offsetX, _offsetY;\n      return {\n        x: p.x + ((_offsetX = offsetX) !== null && _offsetX !== void 0 ? _offsetX : 0),\n        y: p.y + ((_offsetY = offsetY) !== null && _offsetY !== void 0 ? _offsetY : 0)\n      };\n    });\n    vTargetLines = pointsToVLines(correctedTargetPoints);\n    vTargetLineKeys = Array.from(vTargetLines.keys()); // 对应 x\n\n    if (offsetX !== undefined) {\n      /*************** 标记需要绘制的垂直参考线 ************/\n      forEach(vTargetLineKeys, (y, i) => {\n        if (isEqualNum(offsetX, closestXDiffs[i])) {\n          var _ref;\n          const vLine = {\n            x: closestXs[i],\n            ys: []\n          };\n          vLine.ys.push(...vTargetLines.get(y));\n          vLine.ys.push(...Array.from((_ref = vRefLineMap.get(y)) !== null && _ref !== void 0 ? _ref : []));\n          this.toDrawVLines.push(vLine);\n        }\n      });\n    }\n    if (offsetY !== undefined) {\n      /*************** 标记需要绘制的水平参考线 ************/\n      hTargetLines = pointsToHLines(correctedTargetPoints);\n      hTargetLineKeys = Array.from(hTargetLines.keys()); // 对应 y\n\n      forEach(hTargetLineKeys, (x, i) => {\n        if (isEqualNum(offsetY, closestYDiffs[i])) {\n          var _hRefLineMap$get;\n          const hLine = {\n            y: closestYs[i],\n            xs: []\n          };\n          hLine.xs.push(...hTargetLines.get(x));\n          hLine.xs.push(...Array.from((_hRefLineMap$get = hRefLineMap.get(x)) !== null && _hRefLineMap$get !== void 0 ? _hRefLineMap$get : []));\n          this.toDrawHLines.push(hLine);\n        }\n      });\n    }\n    return {\n      offsetX: (_offsetX2 = offsetX) !== null && _offsetX2 !== void 0 ? _offsetX2 : 0,\n      offsetY: (_offsetY2 = offsetY) !== null && _offsetY2 !== void 0 ? _offsetY2 : 0\n    };\n  }\n  drawRefLine(ctx) {\n    ctx.save();\n    const color = this.editor.setting.get('refLineStroke');\n    ctx.fillStyle = color;\n    ctx.strokeStyle = color;\n    ctx.lineWidth = this.editor.setting.get('refLineStrokeWidth');\n    const pointsSet = new Set();\n    const pointSize = this.editor.setting.get('refLinePointSize');\n    this.drawVerticalLines(ctx, pointSize, pointsSet);\n    this.drawHorizontalLines(ctx, pointSize, pointsSet);\n    ctx.restore();\n  }\n  drawVerticalLines(ctx, pointSize, pointsSet) {\n    for (const vLine of this.toDrawVLines) {\n      let minY = Infinity;\n      let maxY = -Infinity;\n      const {\n        x\n      } = this.editor.sceneCoordsToViewport(vLine.x, 0);\n      for (const y_ of vLine.ys) {\n        // TODO: optimize\n        const {\n          y\n        } = this.editor.sceneCoordsToViewport(0, y_);\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n\n        // prevent draw same points again\n        const key = `${x},${y}`;\n        if (pointsSet.has(key)) {\n          continue;\n        }\n        pointsSet.add(key);\n        drawXShape(ctx, x, y, pointSize);\n      }\n      drawLine(ctx, x, minY, x, maxY);\n    }\n  }\n  drawHorizontalLines(ctx, pointSize, pointsSet) {\n    for (const hLine of this.toDrawHLines) {\n      let minX = Infinity;\n      let maxX = -Infinity;\n      const {\n        y\n      } = this.editor.sceneCoordsToViewport(0, hLine.y);\n      for (const x_ of hLine.xs) {\n        const {\n          x\n        } = this.editor.sceneCoordsToViewport(x_, 0);\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n\n        // prevent draw same points again\n        const key = `${x},${y}`;\n        if (pointsSet.has(key)) {\n          continue;\n        }\n        pointsSet.add(key);\n        drawXShape(ctx, x, y, pointSize);\n      }\n      drawLine(ctx, minX, y, maxX, y);\n    }\n  }\n}","map":{"version":3,"names":["bboxToBbox2","bboxToBboxWithMid","isRectIntersect2","pointsToHLines","pointsToVLines","getClosestValInSortedArr","drawLine","drawXShape","arrMap","forEach","RefLine","constructor","editor","vRefLineMap","Map","hRefLineMap","sortedXs","sortedYs","toDrawVLines","toDrawHLines","cacheXYToBbox","clear","selectIdSet","selectedElements","getIdSet","viewportBbox","viewportManager","getBbox2","graph","sceneGraph","children","has","id","bbox","getBBox2","addBboxToMap","midX","minY","maxY","midY","minX","maxX","bboxVerts","getBboxVerts","top","filter","p","x","bottom","left","y","right","Array","from","keys","sort","a","b","m","xOrY","xsOrYs","line","get","add","set","Set","getTargetPointFromSelect","targetPoints","size","targetGraph","getItems","getCenter","targetBbox","getBBox","updateRefLine","_offsetX2","_offsetY2","vTargetLines","vTargetLineKeys","hTargetLines","hTargetLineKeys","length","offsetX","offsetY","undefined","closestXs","closestXDiffs","i","closestXDist","Math","min","item","abs","closestYs","closestYDiffs","closestYDist","isEqualNum","tol","setting","zoomManager","getZoom","Error","correctedTargetPoints","_offsetX","_offsetY","_ref","vLine","ys","push","_hRefLineMap$get","hLine","xs","drawRefLine","ctx","save","color","fillStyle","strokeStyle","lineWidth","pointsSet","pointSize","drawVerticalLines","drawHorizontalLines","restore","Infinity","sceneCoordsToViewport","y_","max","key","x_"],"sources":["/Users/yangdan/zf-workspace/react/suika/packages/suika/src/editor/ref_line.ts"],"sourcesContent":["import { Editor } from './editor';\nimport { IPoint, IVerticalLine, IHorizontalLine } from '../type';\nimport {\n  bboxToBbox2,\n  bboxToBboxWithMid,\n  isRectIntersect2,\n  pointsToHLines,\n  pointsToVLines,\n} from '../utils/graphics';\nimport { getClosestValInSortedArr } from '../utils/common';\nimport { drawLine, drawXShape } from '../utils/canvas';\nimport { arrMap, forEach } from '../utils/array_util';\n\n/**\n * reference line\n */\nexport class RefLine {\n  /**\n   * 参考图形产生的垂直参照线。对于其中的同一条线，x 相同（作为 key），y 不同（作为 value）\n   */\n  private vRefLineMap = new Map<number, Set<number>>();\n  /**\n   * 参考图形产生的水平照线，对于其中的同一条线，y 相同（作为 key），x 不同（作为 value）\n   */\n  private hRefLineMap = new Map<number, Set<number>>();\n\n  private sortedXs: number[] = []; // 对 vRefLineMap 的 key 排序\n  private sortedYs: number[] = []; // 对 hRefLineMap 的 key 排序\n\n  private toDrawVLines: IVerticalLine[] = []; // 等待绘制的垂直参照线\n  private toDrawHLines: IHorizontalLine[] = []; // 等待绘制的水平参照线\n\n  constructor(private editor: Editor) {}\n\n  cacheXYToBbox() {\n    this.clear();\n\n    const vRefLineMap = this.vRefLineMap;\n    const hRefLineMap = this.hRefLineMap;\n\n    const selectIdSet = this.editor.selectedElements.getIdSet();\n    const viewportBbox = this.editor.viewportManager.getBbox2();\n    for (const graph of this.editor.sceneGraph.children) {\n      if (selectIdSet.has(graph.id)) {\n        continue;\n      }\n\n      const bbox = bboxToBboxWithMid(graph.getBBox2());\n      if (!isRectIntersect2(viewportBbox, bbox)) {\n        continue;\n      }\n\n      // bbox 中水平线\n      this.addBboxToMap(vRefLineMap, bbox.midX, [bbox.minY, bbox.maxY]);\n      // bbox 中垂直线\n      this.addBboxToMap(hRefLineMap, bbox.midY, [bbox.minX, bbox.maxX]);\n\n      /**\n       * 获取旋转后4个顶点的坐标\n       *      top\n       *     /   \\\n       *   /       \\\n       * left      right\n       *   \\       /\n       *    \\    /\n       *    bottom\n       *\n       * special when rotate 90 degree:\n       *\n       * top(left) ---------- right(top)\n       *      |                 |\n       * left(bottom) ------- bottom(right)\n       *\n       * top 和 bottom 要绘制水平参考线，不要绘制垂直参照线\n       * left 和 right 要绘制垂直参照线，不要绘制水平参照线\n       */\n      const bboxVerts = graph.getBboxVerts();\n      const top = bboxVerts.filter((p) => p.x === bbox.minX);\n      const bottom = bboxVerts.filter((p) => p.x === bbox.maxX);\n      const left = bboxVerts.filter((p) => p.y === bbox.minY);\n      const right = bboxVerts.filter((p) => p.y === bbox.maxY);\n\n      // top 和 bottom 要绘制水平参考线，不要绘制垂直参照线\n      [...top, ...bottom].forEach((p) => {\n        this.addBboxToMap(vRefLineMap, p.x, [p.y]);\n      });\n      // left 和 right 要绘制垂直参照线，不要绘制水平参照线\n      [...left, ...right].forEach((p) => {\n        this.addBboxToMap(hRefLineMap, p.y, [p.x]);\n      });\n    }\n\n    this.sortedXs = Array.from(vRefLineMap.keys()).sort((a, b) => a - b);\n    this.sortedYs = Array.from(hRefLineMap.keys()).sort((a, b) => a - b);\n  }\n  clear() {\n    this.vRefLineMap.clear();\n    this.hRefLineMap.clear();\n    this.sortedXs = [];\n    this.sortedYs = [];\n    this.toDrawVLines = [];\n    this.toDrawHLines = [];\n  }\n  private addBboxToMap(\n    m: Map<number, Set<number>>,\n    xOrY: number,\n    xsOrYs: number[],\n  ) {\n    const line = m.get(xOrY);\n    if (line) {\n      forEach(xsOrYs, (xOrY) => {\n        line.add(xOrY);\n      });\n    } else {\n      m.set(xOrY, new Set(xsOrYs));\n    }\n  }\n\n  private getTargetPointFromSelect() {\n    let targetPoints: IPoint[] = [];\n    // 选中的为单个图形，要以旋转后的 4 个顶点和中心点为目标线\n    if (this.editor.selectedElements.size() === 1) {\n      const [targetGraph] = this.editor.selectedElements.getItems();\n      targetPoints = [...targetGraph.getBboxVerts(), targetGraph.getCenter()];\n    } else {\n      const targetBbox = bboxToBboxWithMid(\n        bboxToBbox2(this.editor.selectedElements.getBBox()!),\n      );\n      targetPoints = [\n        { x: targetBbox.minX, y: targetBbox.minY },\n        { x: targetBbox.minX, y: targetBbox.maxY },\n\n        { x: targetBbox.maxX, y: targetBbox.minY },\n        { x: targetBbox.maxX, y: targetBbox.maxY },\n\n        { x: targetBbox.midX, y: targetBbox.midY },\n      ];\n    }\n    return targetPoints;\n  }\n\n  /**\n   * update ref line\n   * and return offset\n   */\n  updateRefLine(): {\n    offsetX: number;\n    offsetY: number;\n  } {\n    const targetPoints = this.getTargetPointFromSelect();\n\n    this.toDrawVLines = [];\n    this.toDrawHLines = [];\n\n    let vTargetLines = pointsToVLines(targetPoints); // 目标矩形的垂直线\n    let vTargetLineKeys = Array.from(vTargetLines.keys()); // 目标矩形的垂直线的 x 坐标\n    let hTargetLines = pointsToHLines(targetPoints); // 目标矩形的水平线\n    let hTargetLineKeys = Array.from(hTargetLines.keys()); // 目标矩形的水平线的 y 坐标\n\n    const vRefLineMap = this.vRefLineMap;\n    const hRefLineMap = this.hRefLineMap;\n    const sortedXs = this.sortedXs;\n    const sortedYs = this.sortedYs;\n\n    // there are no reference graphs\n    if (sortedXs.length === 0 && sortedYs.length === 0) {\n      return { offsetX: 0, offsetY: 0 };\n    }\n\n    let offsetX: number | undefined = undefined;\n    let offsetY: number | undefined = undefined;\n\n    const closestXs = arrMap(vTargetLineKeys, (x) =>\n      getClosestValInSortedArr(sortedXs, x),\n    );\n    // 目标矩形的每个 x 坐标离它们最近的参照线的差值\n    const closestXDiffs = arrMap(vTargetLineKeys, (x, i) => closestXs[i] - x);\n    const closestXDist = Math.min(\n      ...arrMap(closestXDiffs, (item) => Math.abs(item)),\n    );\n\n    const closestYs = arrMap(hTargetLineKeys, (y) =>\n      getClosestValInSortedArr(sortedYs, y),\n    );\n    // 目标矩形的每个 y 坐标离它们最近的参照线的差值\n    const closestYDiffs = arrMap(hTargetLineKeys, (y, i) => closestYs[i] - y);\n    const closestYDist = Math.min(\n      ...arrMap(closestYDiffs, (item) => Math.abs(item)),\n    );\n\n    const isEqualNum = (a: number, b: number) => Math.abs(a - b) < 0.00001;\n\n    const tol =\n      this.editor.setting.get('refLineTolerance') /\n      this.editor.zoomManager.getZoom();\n\n    // 确定最终偏移值 offsetX\n    if (closestXDist <= tol) {\n      for (let i = 0; i < closestXDiffs.length; i++) {\n        if (isEqualNum(closestXDist, Math.abs(closestXDiffs[i]))) {\n          offsetX = closestXDiffs[i];\n          break;\n        }\n      }\n      if (offsetX === undefined) {\n        throw new Error('it should not reach here, please put a issue to us');\n      }\n    }\n\n    // 再确认偏移值 offsetY\n    if (closestYDist <= tol) {\n      for (let i = 0; i < closestYDiffs.length; i++) {\n        if (isEqualNum(closestYDist, Math.abs(closestYDiffs[i]))) {\n          offsetY = closestYDiffs[i];\n          break;\n        }\n      }\n      if (offsetY === undefined) {\n        throw new Error('it should not reach here, please put a issue to us');\n      }\n    }\n\n    const correctedTargetPoints: IPoint[] = arrMap(targetPoints, (p) => ({\n      x: p.x + (offsetX ?? 0),\n      y: p.y + (offsetY ?? 0),\n    }));\n\n    vTargetLines = pointsToVLines(correctedTargetPoints);\n    vTargetLineKeys = Array.from(vTargetLines.keys()); // 对应 x\n\n    if (offsetX !== undefined) {\n      /*************** 标记需要绘制的垂直参考线 ************/\n      forEach(vTargetLineKeys, (y, i) => {\n        if (isEqualNum(offsetX!, closestXDiffs[i])) {\n          const vLine: IVerticalLine = {\n            x: closestXs[i],\n            ys: [],\n          };\n\n          vLine.ys.push(...vTargetLines.get(y)!);\n          vLine.ys.push(...Array.from(vRefLineMap.get(y)! ?? []));\n          this.toDrawVLines.push(vLine);\n        }\n      });\n    }\n\n    if (offsetY !== undefined) {\n      /*************** 标记需要绘制的水平参考线 ************/\n      hTargetLines = pointsToHLines(correctedTargetPoints);\n      hTargetLineKeys = Array.from(hTargetLines.keys()); // 对应 y\n\n      forEach(hTargetLineKeys, (x, i) => {\n        if (isEqualNum(offsetY!, closestYDiffs[i])) {\n          const hLine: IHorizontalLine = {\n            y: closestYs[i],\n            xs: [],\n          };\n\n          hLine.xs.push(...hTargetLines.get(x)!);\n          hLine.xs.push(...Array.from(hRefLineMap.get(x) ?? []));\n\n          this.toDrawHLines.push(hLine);\n        }\n      });\n    }\n\n    return { offsetX: offsetX ?? 0, offsetY: offsetY ?? 0 };\n  }\n\n  drawRefLine(ctx: CanvasRenderingContext2D) {\n    ctx.save();\n\n    const color = this.editor.setting.get('refLineStroke');\n    ctx.fillStyle = color;\n    ctx.strokeStyle = color;\n    ctx.lineWidth = this.editor.setting.get('refLineStrokeWidth');\n\n    const pointsSet = new Set<string>();\n    const pointSize = this.editor.setting.get('refLinePointSize');\n\n    this.drawVerticalLines(ctx, pointSize, pointsSet);\n    this.drawHorizontalLines(ctx, pointSize, pointsSet);\n\n    ctx.restore();\n  }\n\n  private drawVerticalLines(\n    ctx: CanvasRenderingContext2D,\n    pointSize: number,\n    pointsSet: Set<string>,\n  ) {\n    for (const vLine of this.toDrawVLines) {\n      let minY = Infinity;\n      let maxY = -Infinity;\n\n      const { x } = this.editor.sceneCoordsToViewport(vLine.x, 0);\n      for (const y_ of vLine.ys) {\n        // TODO: optimize\n        const { y } = this.editor.sceneCoordsToViewport(0, y_);\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n\n        // prevent draw same points again\n        const key = `${x},${y}`;\n        if (pointsSet.has(key)) {\n          continue;\n        }\n        pointsSet.add(key);\n\n        drawXShape(ctx, x, y, pointSize);\n      }\n\n      drawLine(ctx, x, minY, x, maxY);\n    }\n  }\n\n  private drawHorizontalLines(\n    ctx: CanvasRenderingContext2D,\n    pointSize: number,\n    pointsSet: Set<string>,\n  ) {\n    for (const hLine of this.toDrawHLines) {\n      let minX = Infinity;\n      let maxX = -Infinity;\n\n      const { y } = this.editor.sceneCoordsToViewport(0, hLine.y);\n\n      for (const x_ of hLine.xs) {\n        const { x } = this.editor.sceneCoordsToViewport(x_, 0);\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n\n        // prevent draw same points again\n        const key = `${x},${y}`;\n        if (pointsSet.has(key)) {\n          continue;\n        }\n        pointsSet.add(key);\n\n        drawXShape(ctx, x, y, pointSize);\n      }\n\n      drawLine(ctx, minX, y, maxX, y);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}