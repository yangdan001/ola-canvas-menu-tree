{"ast":null,"code":"import { GraphType } from '../../type';\nimport { rotateInCanvas } from '../../utils/canvas';\nimport EventEmitter from '../../utils/event_emitter';\nimport { getRectCenterPoint, getRectsBBox, isPointInRect, isRectContain, isRectIntersect } from '../../utils/graphics';\nimport rafThrottle from '../../utils/raf_throttle';\nimport { transformRotate } from '../../utils/transform';\nimport { Ellipse } from './ellipse';\nimport { Graph } from './graph';\nimport { Rect } from './rect';\nimport { TransformHandle } from './transform_handle';\nimport { forEach } from '../../utils/array_util';\nimport Grid from '../grid';\nimport { getDevicePixelRatio } from '../../utils/common';\nimport { TextGraph } from './text';\nimport { HALF_PI } from '../../constant';\nimport { Line } from './line';\n/**\n * 图形树\n */\nexport class SceneGraph {\n  constructor(editor) {\n    this.editor = editor;\n    this.children = [];\n    this.selection = null;\n    // private handle: { rotation: IPoint } | null = null;\n    this.eventEmitter = new EventEmitter();\n    this.transformHandle = void 0;\n    this.grid = void 0;\n    this.showOutline = true;\n    // 全局重渲染\n    this.render = rafThrottle(() => {\n      // 获取视口区域\n      const {\n        viewportManager,\n        canvasElement: canvas,\n        ctx,\n        setting\n      } = this.editor;\n      const viewport = viewportManager.getViewport();\n      const zoom = this.editor.zoomManager.getZoom();\n      const viewportBoxInScene = this.editor.viewportManager.getBbox();\n      const visibleElements = [];\n      // 1. 找出视口下所有元素\n      // 暂时都认为是矩形\n      for (let i = 0, len = this.children.length; i < len; i++) {\n        const shape = this.children[i];\n        if (isRectIntersect(shape.getBBox(), viewportBoxInScene)) {\n          visibleElements.push(shape);\n        }\n      }\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n      // 2. 清空画布，然后绘制所有可见元素\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // 绘制背景色\n      ctx.save();\n      ctx.fillStyle = setting.get('canvasBgColor');\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      ctx.restore();\n\n      // 场景坐标转换为视口坐标\n      const dpr = getDevicePixelRatio();\n      const dx = -viewport.x;\n      const dy = -viewport.y;\n      ctx.scale(dpr * zoom, dpr * zoom);\n      ctx.translate(dx, dy);\n      for (let i = 0, len = visibleElements.length; i < len; i++) {\n        ctx.save();\n        const element = visibleElements[i];\n        // 抗锯齿\n        const smooth = zoom <= 1;\n        element.renderFillAndStrokeTexture(ctx, smooth);\n        ctx.restore();\n      }\n\n      /******************* 绘制辅助线层 ********************/\n      ctx.save();\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.scale(dpr, dpr);\n      const selectedElementsBBox = this.editor.selectedElements.getBBox();\n\n      // 1. draw pixel grid\n      if (setting.get('enablePixelGrid') && zoom >= this.editor.setting.get('minPixelGridZoom')) {\n        this.grid.draw();\n      }\n\n      // 2. draw selected elements bbox\n      if (this.showOutline) {\n        this.highLightSelectedBox(selectedElementsBBox);\n      }\n\n      // 3. draw selectionBox\n      if (this.selection) {\n        ctx.save();\n        ctx.strokeStyle = setting.get('selectionStroke');\n        ctx.fillStyle = setting.get('selectionFill');\n        const {\n          x,\n          y,\n          width,\n          height\n        } = this.selection;\n        const {\n          x: xInViewport,\n          y: yInViewport\n        } = this.editor.sceneCoordsToViewport(x, y);\n        const widthInViewport = width * zoom;\n        const heightInViewport = height * zoom;\n        ctx.fillRect(xInViewport, yInViewport, widthInViewport, heightInViewport);\n        ctx.strokeRect(xInViewport, yInViewport, widthInViewport, heightInViewport);\n        ctx.restore();\n      }\n\n      // 4. draw transform handle\n      if (this.showOutline) {\n        this.transformHandle.draw(selectedElementsBBox);\n      }\n      this.editor.refLine.drawRefLine(ctx);\n\n      // 5. drawing rulers\n      if (setting.get('enableRuler')) {\n        this.editor.ruler.draw();\n      }\n      ctx.restore();\n      this.eventEmitter.emit('render');\n    });\n    this.transformHandle = new TransformHandle(editor);\n    this.grid = new Grid(editor);\n  }\n  addItems(element, idx) {\n    if (idx === undefined) {\n      this.children.push(...element);\n    } else {\n      this.children.splice(idx, 0, ...element);\n    }\n  }\n  getElementById(id) {\n    return this.children.find(item => item.id === id);\n  }\n  removeItems(elements) {\n    if (elements.length > 1) {\n      forEach(elements, element => {\n        this.removeItems([element]);\n      });\n    } else {\n      const element = elements[0];\n      const idx = this.children.indexOf(element);\n      if (idx !== -1) {\n        this.children.splice(idx, 1);\n      }\n    }\n  }\n  /**\n   * 光标是否落在旋转控制点上\n   */\n  /**\n   * 绘制每个元素的轮廓，以及包围它们的包围盒\n   */\n  highLightSelectedBox(selectedElementsBBox) {\n    /******* 绘制每个元素的包围盒（FIXME: 改为绘制轮廓） *******/\n    if (selectedElementsBBox === null) {\n      return;\n    }\n    const selectedElements = this.editor.selectedElements.getItems();\n    const bBoxes = selectedElements.map(element => element.getBBoxWithoutRotation());\n    const zoom = this.editor.zoomManager.getZoom();\n    const ctx = this.editor.ctx;\n    ctx.save();\n    // TODO: 椭圆图形，要绘制圆形轮廓\n    for (let i = 0, len = bBoxes.length; i < len; i++) {\n      ctx.save();\n      const bBox = bBoxes[i];\n      ctx.strokeStyle = this.editor.setting.get('guideBBoxStroke');\n      const currElement = selectedElements[i];\n      if (currElement.rotation) {\n        const [cx, cy] = getRectCenterPoint(bBox);\n        const {\n          x: cxInViewport,\n          y: cyInViewport\n        } = this.editor.sceneCoordsToViewport(cx, cy);\n        rotateInCanvas(ctx, currElement.rotation, cxInViewport, cyInViewport);\n      }\n      const {\n        x: xInViewport,\n        y: yInViewport\n      } = this.editor.sceneCoordsToViewport(bBox.x, bBox.y);\n      ctx.strokeRect(xInViewport, yInViewport, bBox.width * zoom, bBox.height * zoom);\n      ctx.restore();\n    }\n\n    /********** 绘制多个图形组成的包围盒 *********/\n    // 只有单个选中元素，不绘制选中盒\n\n    // 多个选中元素时，才绘制选中盒\n    if (selectedElements.length > 1) {\n      ctx.strokeStyle = this.editor.setting.get('guideBBoxStroke');\n      const {\n        x: xInViewport,\n        y: yInViewport\n      } = this.editor.sceneCoordsToViewport(selectedElementsBBox.x, selectedElementsBBox.y);\n      ctx.strokeRect(xInViewport, yInViewport, selectedElementsBBox.width * zoom, selectedElementsBBox.height * zoom);\n    }\n    ctx.restore();\n  }\n  /**\n   * 点是否在选中框（selectedBox）中\n   */\n  isPointInSelectedBox(point) {\n    const selectedElements = this.editor.selectedElements.getItems();\n    if (selectedElements.length === 0) {\n      return false;\n    }\n    let bBoxes;\n    // 【单个元素被选中】求不考虑旋转的 bBox，将其和旋转后的角度比较\n    if (selectedElements.length === 1) {\n      bBoxes = selectedElements.map(element => element.getBBoxWithoutRotation());\n      // 单个元素，要考虑旋转\n      const element = selectedElements[0];\n      const [cx, cy] = getRectCenterPoint(element);\n      if (element.rotation) {\n        point = transformRotate(point.x, point.y, -element.rotation, cx, cy);\n      }\n    }\n    // 【多个元素被选中】\n    else {\n      bBoxes = selectedElements.map(element => element.getBBox());\n    }\n    const composedBBox = getRectsBBox(...bBoxes);\n    return isPointInRect(point, composedBBox);\n  }\n  getTopHitElement(x, y) {\n    const padding = this.editor.setting.get('selectionHitPadding') / this.editor.zoomManager.getZoom();\n\n    // TODO: optimize, use r-tree to reduce time complexity\n    for (let i = this.children.length - 1; i >= 0; i--) {\n      const el = this.children[i];\n      if (el.hitTest(x, y, padding)) {\n        return el;\n      }\n    }\n    return null;\n  }\n  setSelection(partialRect) {\n    this.selection = Object.assign({}, this.selection, partialRect);\n  }\n  getElementsInSelection() {\n    const selection = this.selection;\n    if (selection === null) {\n      console.warn('selection 为 null，请确认在正确的时机调用当前方法');\n      return [];\n    }\n    const selectionMode = this.editor.setting.get('selectionMode');\n    const elements = this.children;\n    const containedElements = [];\n    // TODO: optimize, use r-tree to reduce time complexity\n    for (const el of elements) {\n      let isSelected = false;\n      if (selectionMode === 'contain') {\n        isSelected = isRectContain(selection, el.getBBox());\n      } else {\n        // intersect mode\n        // if selection mode is invalid, rollback to intersect mode\n\n        // AABB intersect\n        if (!isRectIntersect(selection, el.getBBox())) {\n          isSelected = false;\n        } else {\n          if (!el.rotation || el.rotation % HALF_PI == 0) {\n            isSelected = true;\n          } else {\n            // OBB intersect\n            // use SAT algorithm to check intersect\n            const {\n              x: cx,\n              y: cy\n            } = el.getCenter();\n            const r = -el.rotation;\n            const s1 = transformRotate(selection.x, selection.y, r, cx, cy);\n            const s2 = transformRotate(selection.x + selection.width, selection.y + selection.height, r, cx, cy);\n            const s3 = transformRotate(selection.x + selection.width, selection.y, r, cx, cy);\n            const s4 = transformRotate(selection.x, selection.y + selection.height, r, cx, cy);\n            const rotatedSelectionX = Math.min(s1.x, s2.x, s3.x, s4.x);\n            const rotatedSelectionY = Math.min(s1.y, s2.y, s3.y, s4.y);\n            const rotatedSelectionWidth = Math.max(s1.x, s2.x, s3.x, s4.x) - rotatedSelectionX;\n            const rotatedSelectionHeight = Math.max(s1.y, s2.y, s3.y, s4.y) - rotatedSelectionY;\n            const rotatedSelection = {\n              x: rotatedSelectionX,\n              y: rotatedSelectionY,\n              width: rotatedSelectionWidth,\n              height: rotatedSelectionHeight\n            };\n            isSelected = isRectIntersect(rotatedSelection, {\n              x: el.x,\n              y: el.y,\n              width: el.width,\n              height: el.height\n            });\n          }\n        }\n      }\n      if (isSelected) {\n        containedElements.push(el);\n      }\n    }\n    return containedElements;\n  }\n\n  /**\n   * get simple info (for layer panel)\n   */\n  getObjects() {\n    const children = this.children;\n    const objects = [];\n    forEach(children, item => {\n      objects.push({\n        id: item.id,\n        name: item.objectName\n      });\n    });\n    return objects;\n  }\n  toJSON() {\n    const paperData = {\n      appVersion: 'suika-editor_0.0.1',\n      paperId: this.editor.paperId,\n      data: JSON.stringify(this.children)\n    };\n    return JSON.stringify(paperData);\n  }\n  addGraphsByStr(str) {\n    const ctorMap = {\n      [GraphType.Graph]: Graph,\n      [GraphType.Rect]: Rect,\n      [GraphType.Ellipse]: Ellipse,\n      [GraphType.Line]: Line,\n      [GraphType.Text]: TextGraph\n    };\n    const data = JSON.parse(str);\n    const newChildren = data.map(attrs => {\n      const type = attrs.type;\n      const Ctor = ctorMap[type];\n      if (!Ctor) {\n        throw new Error('found wrong type of graph');\n      }\n      return new Ctor(attrs);\n    });\n    this.children.push(...newChildren);\n    return newChildren;\n  }\n  load(str) {\n    this.children = [];\n    this.addGraphsByStr(str);\n  }\n\n  // TODO: update tree by patch obj and id\n  updateElements() {\n    /**\n     * {\n     *   update: { id: '123', attrs: { width: 1 }  }\n     *   removed: new Set(['8', '9'])\n     *   create: { type: rect, }\n     * }\n     */\n  }\n  on(eventName, handler) {\n    this.eventEmitter.on(eventName, handler);\n  }\n  off(eventName, handler) {\n    this.eventEmitter.off(eventName, handler);\n  }\n}","map":{"version":3,"names":["GraphType","rotateInCanvas","EventEmitter","getRectCenterPoint","getRectsBBox","isPointInRect","isRectContain","isRectIntersect","rafThrottle","transformRotate","Ellipse","Graph","Rect","TransformHandle","forEach","Grid","getDevicePixelRatio","TextGraph","HALF_PI","Line","SceneGraph","constructor","editor","children","selection","eventEmitter","transformHandle","grid","showOutline","render","viewportManager","canvasElement","canvas","ctx","setting","viewport","getViewport","zoom","zoomManager","getZoom","viewportBoxInScene","getBbox","visibleElements","i","len","length","shape","getBBox","push","setTransform","clearRect","width","height","save","fillStyle","get","fillRect","restore","dpr","dx","x","dy","y","scale","translate","element","smooth","renderFillAndStrokeTexture","selectedElementsBBox","selectedElements","draw","highLightSelectedBox","strokeStyle","xInViewport","yInViewport","sceneCoordsToViewport","widthInViewport","heightInViewport","strokeRect","refLine","drawRefLine","ruler","emit","addItems","idx","undefined","splice","getElementById","id","find","item","removeItems","elements","indexOf","getItems","bBoxes","map","getBBoxWithoutRotation","bBox","currElement","rotation","cx","cy","cxInViewport","cyInViewport","isPointInSelectedBox","point","composedBBox","getTopHitElement","padding","el","hitTest","setSelection","partialRect","Object","assign","getElementsInSelection","console","warn","selectionMode","containedElements","isSelected","getCenter","r","s1","s2","s3","s4","rotatedSelectionX","Math","min","rotatedSelectionY","rotatedSelectionWidth","max","rotatedSelectionHeight","rotatedSelection","getObjects","objects","name","objectName","toJSON","paperData","appVersion","paperId","data","JSON","stringify","addGraphsByStr","str","ctorMap","Text","parse","newChildren","attrs","type","Ctor","Error","load","updateElements","on","eventName","handler","off"],"sources":["/Users/yangdan/zf-workspace/react/suika/packages/suika/src/editor/scene/scene_graph.ts"],"sourcesContent":["import { Editor } from '../editor';\nimport {\n  GraphType,\n  IBox,\n  IEditorPaperData,\n  IObject,\n  IPoint,\n  IRect,\n} from '../../type';\nimport { rotateInCanvas } from '../../utils/canvas';\nimport EventEmitter from '../../utils/event_emitter';\nimport {\n  getRectCenterPoint,\n  getRectsBBox,\n  isPointInRect,\n  isRectContain,\n  isRectIntersect,\n} from '../../utils/graphics';\nimport rafThrottle from '../../utils/raf_throttle';\nimport { transformRotate } from '../../utils/transform';\nimport { Ellipse } from './ellipse';\nimport { Graph, GraphAttrs } from './graph';\nimport { Rect } from './rect';\nimport { TransformHandle } from './transform_handle';\nimport { forEach } from '../../utils/array_util';\nimport Grid from '../grid';\nimport { getDevicePixelRatio } from '../../utils/common';\nimport { TextGraph } from './text';\nimport { HALF_PI } from '../../constant';\nimport { Line } from './line';\n\ninterface Events {\n  render(): void;\n}\n\n/**\n * 图形树\n */\nexport class SceneGraph {\n  children: Graph[] = [];\n  selection: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  } | null = null;\n  // private handle: { rotation: IPoint } | null = null;\n  private eventEmitter = new EventEmitter<Events>();\n  transformHandle: TransformHandle;\n  grid: Grid;\n  showOutline = true;\n\n  constructor(private editor: Editor) {\n    this.transformHandle = new TransformHandle(editor);\n    this.grid = new Grid(editor);\n  }\n  addItems(element: Graph[], idx?: number) {\n    if (idx === undefined) {\n      this.children.push(...element);\n    } else {\n      this.children.splice(idx, 0, ...element);\n    }\n  }\n  getElementById(id: string) {\n    return this.children.find((item) => item.id === id);\n  }\n  removeItems(elements: Graph[]) {\n    if (elements.length > 1) {\n      forEach(elements, (element) => {\n        this.removeItems([element]);\n      });\n    } else {\n      const element = elements[0];\n      const idx = this.children.indexOf(element);\n      if (idx !== -1) {\n        this.children.splice(idx, 1);\n      }\n    }\n  }\n  // 全局重渲染\n  render = rafThrottle(() => {\n    // 获取视口区域\n    const {\n      viewportManager,\n      canvasElement: canvas,\n      ctx,\n      setting,\n    } = this.editor;\n    const viewport = viewportManager.getViewport();\n    const zoom = this.editor.zoomManager.getZoom();\n    const viewportBoxInScene = this.editor.viewportManager.getBbox();\n\n    const visibleElements: Graph[] = [];\n    // 1. 找出视口下所有元素\n    // 暂时都认为是矩形\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      const shape = this.children[i];\n\n      if (isRectIntersect(shape.getBBox(), viewportBoxInScene)) {\n        visibleElements.push(shape);\n      }\n    }\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n    // 2. 清空画布，然后绘制所有可见元素\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // 绘制背景色\n    ctx.save();\n    ctx.fillStyle = setting.get('canvasBgColor');\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n\n    // 场景坐标转换为视口坐标\n    const dpr = getDevicePixelRatio();\n\n    const dx = -viewport.x;\n    const dy = -viewport.y;\n    ctx.scale(dpr * zoom, dpr * zoom);\n    ctx.translate(dx, dy);\n\n    for (let i = 0, len = visibleElements.length; i < len; i++) {\n      ctx.save();\n      const element = visibleElements[i];\n      // 抗锯齿\n      const smooth = zoom <= 1;\n      element.renderFillAndStrokeTexture(ctx, smooth);\n      ctx.restore();\n    }\n\n    /******************* 绘制辅助线层 ********************/\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.scale(dpr, dpr);\n\n    const selectedElementsBBox = this.editor.selectedElements.getBBox();\n\n    // 1. draw pixel grid\n    if (\n      setting.get('enablePixelGrid') &&\n      zoom >= this.editor.setting.get('minPixelGridZoom')\n    ) {\n      this.grid.draw();\n    }\n\n    // 2. draw selected elements bbox\n    if (this.showOutline) {\n      this.highLightSelectedBox(selectedElementsBBox);\n    }\n\n    // 3. draw selectionBox\n    if (this.selection) {\n      ctx.save();\n      ctx.strokeStyle = setting.get('selectionStroke');\n      ctx.fillStyle = setting.get('selectionFill');\n      const { x, y, width, height } = this.selection;\n\n      const { x: xInViewport, y: yInViewport } =\n        this.editor.sceneCoordsToViewport(x, y);\n\n      const widthInViewport = width * zoom;\n      const heightInViewport = height * zoom;\n\n      ctx.fillRect(xInViewport, yInViewport, widthInViewport, heightInViewport);\n      ctx.strokeRect(\n        xInViewport,\n        yInViewport,\n        widthInViewport,\n        heightInViewport,\n      );\n      ctx.restore();\n    }\n\n    // 4. draw transform handle\n    if (this.showOutline) {\n      this.transformHandle.draw(selectedElementsBBox);\n    }\n\n    this.editor.refLine.drawRefLine(ctx);\n\n    // 5. drawing rulers\n    if (setting.get('enableRuler')) {\n      this.editor.ruler.draw();\n    }\n\n    ctx.restore();\n\n    this.eventEmitter.emit('render');\n  });\n  /**\n   * 光标是否落在旋转控制点上\n   */\n\n  /**\n   * 绘制每个元素的轮廓，以及包围它们的包围盒\n   */\n  private highLightSelectedBox(selectedElementsBBox: IBox | null) {\n    /******* 绘制每个元素的包围盒（FIXME: 改为绘制轮廓） *******/\n    if (selectedElementsBBox === null) {\n      return;\n    }\n    const selectedElements = this.editor.selectedElements.getItems();\n\n    const bBoxes = selectedElements.map((element) =>\n      element.getBBoxWithoutRotation(),\n    );\n\n    const zoom = this.editor.zoomManager.getZoom();\n    const ctx = this.editor.ctx;\n\n    ctx.save();\n    // TODO: 椭圆图形，要绘制圆形轮廓\n    for (let i = 0, len = bBoxes.length; i < len; i++) {\n      ctx.save();\n      const bBox = bBoxes[i];\n      ctx.strokeStyle = this.editor.setting.get('guideBBoxStroke');\n\n      const currElement = selectedElements[i];\n      if (currElement.rotation) {\n        const [cx, cy] = getRectCenterPoint(bBox);\n        const { x: cxInViewport, y: cyInViewport } =\n          this.editor.sceneCoordsToViewport(cx, cy);\n        rotateInCanvas(ctx, currElement.rotation, cxInViewport, cyInViewport);\n      }\n      const { x: xInViewport, y: yInViewport } =\n        this.editor.sceneCoordsToViewport(bBox.x, bBox.y);\n      ctx.strokeRect(\n        xInViewport,\n        yInViewport,\n        bBox.width * zoom,\n        bBox.height * zoom,\n      );\n      ctx.restore();\n    }\n\n    /********** 绘制多个图形组成的包围盒 *********/\n    // 只有单个选中元素，不绘制选中盒\n\n    // 多个选中元素时，才绘制选中盒\n    if (selectedElements.length > 1) {\n      ctx.strokeStyle = this.editor.setting.get('guideBBoxStroke');\n      const { x: xInViewport, y: yInViewport } =\n        this.editor.sceneCoordsToViewport(\n          selectedElementsBBox.x,\n          selectedElementsBBox.y,\n        );\n      ctx.strokeRect(\n        xInViewport,\n        yInViewport,\n        selectedElementsBBox.width * zoom,\n        selectedElementsBBox.height * zoom,\n      );\n    }\n    ctx.restore();\n  }\n  /**\n   * 点是否在选中框（selectedBox）中\n   */\n  isPointInSelectedBox(point: IPoint) {\n    const selectedElements = this.editor.selectedElements.getItems();\n    if (selectedElements.length === 0) {\n      return false;\n    }\n\n    let bBoxes: IBox[];\n    // 【单个元素被选中】求不考虑旋转的 bBox，将其和旋转后的角度比较\n    if (selectedElements.length === 1) {\n      bBoxes = selectedElements.map((element) =>\n        element.getBBoxWithoutRotation(),\n      );\n      // 单个元素，要考虑旋转\n      const element = selectedElements[0];\n      const [cx, cy] = getRectCenterPoint(element);\n      if (element.rotation) {\n        point = transformRotate(point.x, point.y, -element.rotation, cx, cy);\n      }\n    }\n    // 【多个元素被选中】\n    else {\n      bBoxes = selectedElements.map((element) => element.getBBox());\n    }\n    const composedBBox = getRectsBBox(...bBoxes);\n    return isPointInRect(point, composedBBox);\n  }\n  getTopHitElement(x: number, y: number): Graph | null {\n    const padding =\n      this.editor.setting.get('selectionHitPadding') /\n      this.editor.zoomManager.getZoom();\n\n    // TODO: optimize, use r-tree to reduce time complexity\n    for (let i = this.children.length - 1; i >= 0; i--) {\n      const el = this.children[i];\n      if (el.hitTest(x, y, padding)) {\n        return el;\n      }\n    }\n    return null;\n  }\n  setSelection(partialRect: Partial<IRect>) {\n    this.selection = Object.assign({}, this.selection, partialRect);\n  }\n  getElementsInSelection() {\n    const selection = this.selection;\n    if (selection === null) {\n      console.warn('selection 为 null，请确认在正确的时机调用当前方法');\n      return [];\n    }\n\n    const selectionMode = this.editor.setting.get('selectionMode');\n    const elements = this.children;\n    const containedElements: Graph[] = [];\n    // TODO: optimize, use r-tree to reduce time complexity\n    for (const el of elements) {\n      let isSelected = false;\n      if (selectionMode === 'contain') {\n        isSelected = isRectContain(selection, el.getBBox());\n      } else {\n        // intersect mode\n        // if selection mode is invalid, rollback to intersect mode\n\n        // AABB intersect\n        if (!isRectIntersect(selection, el.getBBox())) {\n          isSelected = false;\n        } else {\n          if (!el.rotation || el.rotation % HALF_PI == 0) {\n            isSelected = true;\n          } else {\n            // OBB intersect\n            // use SAT algorithm to check intersect\n            const { x: cx, y: cy } = el.getCenter();\n            const r = -el.rotation;\n            const s1 = transformRotate(selection.x, selection.y, r, cx, cy);\n            const s2 = transformRotate(\n              selection.x + selection.width,\n              selection.y + selection.height,\n              r,\n              cx,\n              cy,\n            );\n            const s3 = transformRotate(\n              selection.x + selection.width,\n              selection.y,\n              r,\n              cx,\n              cy,\n            );\n            const s4 = transformRotate(\n              selection.x,\n              selection.y + selection.height,\n              r,\n              cx,\n              cy,\n            );\n\n            const rotatedSelectionX = Math.min(s1.x, s2.x, s3.x, s4.x);\n            const rotatedSelectionY = Math.min(s1.y, s2.y, s3.y, s4.y);\n            const rotatedSelectionWidth =\n              Math.max(s1.x, s2.x, s3.x, s4.x) - rotatedSelectionX;\n            const rotatedSelectionHeight =\n              Math.max(s1.y, s2.y, s3.y, s4.y) - rotatedSelectionY;\n\n            const rotatedSelection = {\n              x: rotatedSelectionX,\n              y: rotatedSelectionY,\n              width: rotatedSelectionWidth,\n              height: rotatedSelectionHeight,\n            };\n\n            isSelected = isRectIntersect(rotatedSelection, {\n              x: el.x,\n              y: el.y,\n              width: el.width,\n              height: el.height,\n            });\n          }\n        }\n      }\n      if (isSelected) {\n        containedElements.push(el);\n      }\n    }\n    return containedElements;\n  }\n\n  /**\n   * get simple info (for layer panel)\n   */\n  getObjects() {\n    const children = this.children;\n    const objects: IObject[] = [];\n    forEach(children, (item) => {\n      objects.push({ id: item.id, name: item.objectName });\n    });\n    return objects;\n  }\n\n  toJSON() {\n    const paperData: IEditorPaperData = {\n      appVersion: 'suika-editor_0.0.1',\n      paperId: this.editor.paperId,\n      data: JSON.stringify(this.children),\n    };\n    return JSON.stringify(paperData);\n  }\n\n  addGraphsByStr(str: string) {\n    const ctorMap = {\n      [GraphType.Graph]: Graph,\n      [GraphType.Rect]: Rect,\n      [GraphType.Ellipse]: Ellipse,\n      [GraphType.Line]: Line,\n      [GraphType.Text]: TextGraph,\n    };\n\n    const data: GraphAttrs[] = JSON.parse(str);\n    const newChildren = data.map((attrs) => {\n      const type = attrs.type;\n      const Ctor = ctorMap[type!];\n\n      if (!Ctor) {\n        throw new Error('found wrong type of graph');\n      }\n\n      return new Ctor(attrs as any);\n    });\n\n    this.children.push(...newChildren);\n    return newChildren;\n  }\n\n  load(str: string) {\n    this.children = [];\n    this.addGraphsByStr(str);\n  }\n\n  // TODO: update tree by patch obj and id\n  updateElements() {\n    /**\n     * {\n     *   update: { id: '123', attrs: { width: 1 }  }\n     *   removed: new Set(['8', '9'])\n     *   create: { type: rect, }\n     * }\n     */\n  }\n\n  on(eventName: 'render', handler: () => void) {\n    this.eventEmitter.on(eventName, handler);\n  }\n  off(eventName: 'render', handler: () => void) {\n    this.eventEmitter.off(eventName, handler);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}