{"ast":null,"code":"import { v4 as uuidv4 } from 'uuid';\nexport const noop = () => {\n  // do nothing\n};\n\n/**\n * 生成唯一 ID\n */\nexport const genId = () => {\n  return uuidv4();\n};\nexport const objectNameGenerator = {\n  maxIdxMap: new Map(),\n  gen(type) {\n    var _this$maxIdxMap$get;\n    let idx = (_this$maxIdxMap$get = this.maxIdxMap.get(type)) !== null && _this$maxIdxMap$get !== void 0 ? _this$maxIdxMap$get : 0;\n    idx++;\n    this.maxIdxMap.set(type, idx);\n    return `${type} ${idx}`;\n  },\n  setMaxIdx(objectName) {\n    const match = objectName.match(/^(.*)\\s+(\\d+)$/);\n    if (match) {\n      var _this$maxIdxMap$get2;\n      const [, type, idxStr] = match;\n      const idx = Number(idxStr);\n      this.maxIdxMap.set(type, Math.max((_this$maxIdxMap$get2 = this.maxIdxMap.get(type)) !== null && _this$maxIdxMap$get2 !== void 0 ? _this$maxIdxMap$get2 : 0, idx));\n    }\n  }\n};\n\n/**\n * 浅比较\n */\n\nexport const shallowCompare = (a, b) => {\n  for (const i in a) if (!(i in b)) return true;\n  for (const i in b) if (a[i] !== b[i]) return true;\n  return false;\n};\n\n/**\n * 找出离 value 最近的 segment 的倍数值\n */\nexport const getClosestTimesVal = (value, segment) => {\n  const n = Math.floor(value / segment);\n  const left = segment * n;\n  const right = segment * (n + 1);\n  return value - left <= right - value ? left : right;\n};\nexport const viewportCoordsToSceneUtil = (x, y, zoom, scrollX, scrollY,\n/**\n * 是否四舍五入取整\n */\nround = false) => {\n  let newX = scrollX + x / zoom;\n  let newY = scrollY + y / zoom;\n  if (round) {\n    newX = Math.round(newX);\n    newY = Math.round(newY);\n  }\n  return {\n    x: newX,\n    y: newY\n  };\n};\nexport const sceneCoordsToViewportUtil = (x, y, zoom, scrollX, scrollY) => {\n  return {\n    x: (x - scrollX) * zoom,\n    y: (y - scrollY) * zoom\n  };\n};\n\n/**\n * Canvas 中绘制，必须为 x.5 才能绘制一列单独像素，\n * 否则会因为抗锯齿，绘制两列像素，且一个为半透明，导致一种模糊的效果\n *\n * 这个方法会得到值最接近的 x.5 值。\n */\nexport const nearestPixelVal = n => {\n  const left = Math.floor(n);\n  const right = Math.ceil(n);\n  return (n - left < right - n ? left : right) + 0.5;\n};\n\n/**\n * 两个数组是否 “相同”，当作集合一样来对比，元素相同即可。\n * （数组中不会出现相同元素）\n */\n\nexport const isSameArray = (a1, a2) => {\n  if (a1.length !== a2.length) return false;\n  const map = new Map();\n  for (let i = 0, len = a1.length; i < len; i++) {\n    map.set(a1[i], true);\n  }\n  for (let i = 0, len = a2.length; i < len; i++) {\n    if (!map.get(a2[i])) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * 保留两位小数\n * 如果是 0，丢弃 0\n */\nexport const remainDecimal = (num, precision = 2) => {\n  return Number(num.toFixed(precision));\n};\n\n/**\n * 字符串转换为数字，并保留两位小数\n */\nexport const parseToNumber = (str, precision = 2) => {\n  if (!str) return NaN;\n  const num = Number(str);\n  if (Number.isNaN(num)) {\n    return NaN;\n  }\n  return remainDecimal(num, precision);\n};\n\n/**\n * compare two arrays\n */\nexport const shallowCompareArrays = (a1, a2) => {\n  if (a1.length !== a2.length) {\n    return false;\n  }\n  for (let i = 0, len = a1.length; i < len; i++) {\n    if (a1[i] !== a2[i]) return false;\n  }\n  return true;\n};\nexport const getDevicePixelRatio = () => {\n  return window.devicePixelRatio || 1;\n};\nexport const calcCoverScale = (w, h, cw, ch) => {\n  if (w === 0 || h === 0) return 1;\n  const scaleW = cw / w;\n  const scaleH = ch / h;\n  const scale = Math.max(scaleW, scaleH);\n  return scale;\n};\n\n// find the closest value in sorted Array\n// (Thanks for Github copilot)\nexport const getClosestValInSortedArr = (sortedArr, target) => {\n  if (sortedArr.length === 0) {\n    throw new Error('sortedArr can not be empty');\n  }\n  if (sortedArr.length === 1) {\n    return sortedArr[0];\n  }\n  let left = 0;\n  let right = sortedArr.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (sortedArr[mid] === target) {\n      return sortedArr[mid];\n    } else if (sortedArr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  // check if left or right is out of bound\n  if (left >= sortedArr.length) {\n    return sortedArr[right];\n  }\n  if (right < 0) {\n    return sortedArr[left];\n  }\n\n  // check which one is closer\n  return Math.abs(sortedArr[right] - target) <= Math.abs(sortedArr[left] - target) ? sortedArr[right] : sortedArr[left];\n};\nexport const isWindows = navigator.platform.toLowerCase().includes('win') || navigator.userAgent.includes('Windows');","map":{"version":3,"names":["v4","uuidv4","noop","genId","objectNameGenerator","maxIdxMap","Map","gen","type","_this$maxIdxMap$get","idx","get","set","setMaxIdx","objectName","match","_this$maxIdxMap$get2","idxStr","Number","Math","max","shallowCompare","a","b","i","getClosestTimesVal","value","segment","n","floor","left","right","viewportCoordsToSceneUtil","x","y","zoom","scrollX","scrollY","round","newX","newY","sceneCoordsToViewportUtil","nearestPixelVal","ceil","isSameArray","a1","a2","length","map","len","remainDecimal","num","precision","toFixed","parseToNumber","str","NaN","isNaN","shallowCompareArrays","getDevicePixelRatio","window","devicePixelRatio","calcCoverScale","w","h","cw","ch","scaleW","scaleH","scale","getClosestValInSortedArr","sortedArr","target","Error","mid","abs","isWindows","navigator","platform","toLowerCase","includes","userAgent"],"sources":["/Users/yangdan/zf-workspace/react/suika/packages/suika/src/utils/common.ts"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\n\nexport const noop = () => {\n  // do nothing\n};\n\n/**\n * 生成唯一 ID\n */\nexport const genId = () => {\n  return uuidv4();\n};\n\nexport const objectNameGenerator = {\n  maxIdxMap: new Map<string, number>(),\n  gen(type: string) {\n    let idx = this.maxIdxMap.get(type) ?? 0;\n    idx++;\n    this.maxIdxMap.set(type, idx);\n    return `${type} ${idx}`;\n  },\n  setMaxIdx(objectName: string) {\n    const match = objectName.match(/^(.*)\\s+(\\d+)$/);\n    if (match) {\n      const [, type, idxStr] = match;\n      const idx = Number(idxStr);\n      this.maxIdxMap.set(type, Math.max(this.maxIdxMap.get(type) ?? 0, idx));\n    }\n  },\n};\n\n/**\n * 浅比较\n */\ntype IObject = Record<string | symbol, any>;\n\nexport const shallowCompare = (a: IObject, b: IObject) => {\n  for (const i in a) if (!(i in b)) return true;\n  for (const i in b) if (a[i] !== b[i]) return true;\n  return false;\n};\n\n/**\n * 找出离 value 最近的 segment 的倍数值\n */\nexport const getClosestTimesVal = (value: number, segment: number) => {\n  const n = Math.floor(value / segment);\n  const left = segment * n;\n  const right = segment * (n + 1);\n  return value - left <= right - value ? left : right;\n};\n\nexport const viewportCoordsToSceneUtil = (\n  x: number,\n  y: number,\n  zoom: number,\n  scrollX: number,\n  scrollY: number,\n  /**\n   * 是否四舍五入取整\n   */\n  round = false,\n) => {\n  let newX = scrollX + x / zoom;\n  let newY = scrollY + y / zoom;\n  if (round) {\n    newX = Math.round(newX);\n    newY = Math.round(newY);\n  }\n  return {\n    x: newX,\n    y: newY,\n  };\n};\n\nexport const sceneCoordsToViewportUtil = (\n  x: number,\n  y: number,\n  zoom: number,\n  scrollX: number,\n  scrollY: number,\n) => {\n  return {\n    x: (x - scrollX) * zoom,\n    y: (y - scrollY) * zoom,\n  };\n};\n\n/**\n * Canvas 中绘制，必须为 x.5 才能绘制一列单独像素，\n * 否则会因为抗锯齿，绘制两列像素，且一个为半透明，导致一种模糊的效果\n *\n * 这个方法会得到值最接近的 x.5 值。\n */\nexport const nearestPixelVal = (n: number) => {\n  const left = Math.floor(n);\n  const right = Math.ceil(n);\n  return (n - left < right - n ? left : right) + 0.5;\n};\n\n/**\n * 两个数组是否 “相同”，当作集合一样来对比，元素相同即可。\n * （数组中不会出现相同元素）\n */\n\nexport const isSameArray = (a1: unknown[], a2: unknown[]) => {\n  if (a1.length !== a2.length) return false;\n  const map = new Map<unknown, true>();\n  for (let i = 0, len = a1.length; i < len; i++) {\n    map.set(a1[i], true);\n  }\n  for (let i = 0, len = a2.length; i < len; i++) {\n    if (!map.get(a2[i])) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * 保留两位小数\n * 如果是 0，丢弃 0\n */\nexport const remainDecimal = (num: number, precision = 2) => {\n  return Number(num.toFixed(precision));\n};\n\n/**\n * 字符串转换为数字，并保留两位小数\n */\nexport const parseToNumber = (str: string, precision = 2) => {\n  if (!str) return NaN;\n  const num = Number(str);\n  if (Number.isNaN(num)) {\n    return NaN;\n  }\n  return remainDecimal(num, precision);\n};\n\n/**\n * compare two arrays\n */\nexport const shallowCompareArrays = (a1: unknown[], a2: unknown[]) => {\n  if (a1.length !== a2.length) {\n    return false;\n  }\n  for (let i = 0, len = a1.length; i < len; i++) {\n    if (a1[i] !== a2[i]) return false;\n  }\n  return true;\n};\n\nexport const getDevicePixelRatio = () => {\n  return window.devicePixelRatio || 1;\n};\n\nexport const calcCoverScale = (\n  w: number,\n  h: number,\n  cw: number,\n  ch: number,\n): number => {\n  if (w === 0 || h === 0) return 1;\n  const scaleW = cw / w;\n  const scaleH = ch / h;\n  const scale = Math.max(scaleW, scaleH);\n  return scale;\n};\n\n// find the closest value in sorted Array\n// (Thanks for Github copilot)\nexport const getClosestValInSortedArr = (\n  sortedArr: number[],\n  target: number,\n) => {\n  if (sortedArr.length === 0) {\n    throw new Error('sortedArr can not be empty');\n  }\n  if (sortedArr.length === 1) {\n    return sortedArr[0];\n  }\n\n  let left = 0;\n  let right = sortedArr.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n\n    if (sortedArr[mid] === target) {\n      return sortedArr[mid];\n    } else if (sortedArr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  // check if left or right is out of bound\n  if (left >= sortedArr.length) {\n    return sortedArr[right];\n  }\n  if (right < 0) {\n    return sortedArr[left];\n  }\n\n  // check which one is closer\n  return Math.abs(sortedArr[right] - target) <=\n    Math.abs(sortedArr[left] - target)\n    ? sortedArr[right]\n    : sortedArr[left];\n};\n\nexport const isWindows =\n  navigator.platform.toLowerCase().includes('win') ||\n  navigator.userAgent.includes('Windows');\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}