{"ast":null,"code":"import { DOUBLE_PI } from '../constant';\nimport { transformRotate } from './transform';\n\n/**\n * 根据两个坐标点确定一个矩形\n */\nexport function getRectByTwoCoord(point1, point2) {\n  return {\n    x: Math.min(point1.x, point2.x),\n    y: Math.min(point1.y, point2.y),\n    width: Math.abs(point1.x - point2.x),\n    height: Math.abs(point1.y - point2.y)\n  };\n}\n\n/**\n * 标准化 rect\n * 处理可能为负数的 width 和 height\n */\nexport const normalizeRect = ({\n  x,\n  y,\n  width,\n  height\n}) => {\n  const x2 = x + width;\n  const y2 = y + height;\n  return getRectByTwoCoord({\n    x,\n    y\n  }, {\n    x: x2,\n    y: y2\n  });\n};\n\n/**\n * 标准化角度\n */\nexport const normalizeRadian = radian => {\n  radian = radian % DOUBLE_PI;\n  if (radian < 0) {\n    radian += DOUBLE_PI;\n  }\n  return radian;\n};\n\n/**\n * 求多个矩形组成的包围盒\n */\nexport function getRectsBBox(...rects) {\n  if (rects.length === 0) {\n    throw new Error('the count of rect can not be 0');\n  }\n  const minX = Math.min(...rects.map(rect => rect.x));\n  const minY = Math.min(...rects.map(rect => rect.y));\n  const maxX = Math.max(...rects.map(rect => rect.x + rect.width));\n  const maxY = Math.max(...rects.map(rect => rect.y + rect.height));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\n\n/**\n * 点是否在矩形中\n */\nexport function isPointInRect(point, rect, padding = 0) {\n  return point.x >= rect.x - padding && point.y >= rect.y - padding && point.x <= rect.x + rect.width + padding && point.y <= rect.y + rect.height + padding;\n}\n\n/**\n * 点是否在圆形中\n */\nexport function isPointInCircle(point, circle) {\n  const dx = point.x - circle.x;\n  const dy = point.y - circle.y;\n  const dSquare = dx * dx + dy * dy;\n  return dSquare <= circle.radius * circle.radius;\n}\n\n/**\n * 矩形是否相交\n */\nexport function isRectIntersect(rect1, rect2) {\n  return rect1.x <= rect2.x + rect2.width && rect1.x + rect1.width >= rect2.x && rect1.y <= rect2.y + rect2.height && rect1.y + rect1.height >= rect2.y;\n}\nexport function isRectIntersect2(rect1, rect2) {\n  return rect1.minX <= rect2.maxX && rect1.maxX >= rect2.minX && rect1.minY <= rect2.maxY && rect1.maxY >= rect2.minY;\n}\n\n/**\n * 矩形 1 是否包含矩形 2\n */\nexport function isRectContain(rect1, rect2) {\n  return rect1.x <= rect2.x && rect1.y <= rect2.y && rect1.x + rect1.width >= rect2.x + rect2.width && rect1.y + rect1.height >= rect2.y + rect2.height;\n}\nexport function isRectContain2(rect1, rect2) {\n  return rect1.minX <= rect2.minX && rect1.minY <= rect2.minY && rect1.maxX >= rect2.maxX && rect1.maxY >= rect2.maxY;\n}\n\n/**\n * rect 中心点\n */\nexport function getRectCenterPoint({\n  x,\n  y,\n  width,\n  height\n}) {\n  return [x + width / 2, y + height / 2];\n}\n\n/**\n * 求向量到右侧轴(x正半轴)的夹角\n * 范围在 [0, Math.PI * 2)\n */\nexport function calcVectorRadian(cx, cy, x, y) {\n  const a = [x - cx, y - cy];\n  const b = [0, -1];\n  const dotProduct = a[0] * b[0] + a[1] * b[1];\n  const d = Math.sqrt(a[0] * a[0] + a[1] * a[1]) * Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n  let radian = Math.acos(dotProduct / d);\n  if (x < cx) {\n    radian = DOUBLE_PI - radian;\n  }\n  return radian;\n}\n\n/**\n * 弧度转角度\n */\nexport function radian2Degree(radian) {\n  return radian * 180 / Math.PI;\n}\n\n/**\n * 角度转弧度\n */\nexport function degree2Radian(degree) {\n  return degree * Math.PI / 180;\n}\n\n/**\n * 计算绝对坐标\n */\nexport function getAbsoluteCoords(rect) {\n  return [rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, rect.x + rect.width / 2, rect.y + rect.height / 2];\n}\nexport function arr2point([x, y]) {\n  return {\n    x,\n    y\n  };\n}\n\n/**\n * 计算一个形状左上角的坐标，考虑旋转\n */\nexport function getElementRotatedXY(element) {\n  const [cx, cy] = getRectCenterPoint(element);\n  return transformRotate(element.x, element.y, element.rotation || 0, cx, cy);\n}\nexport const bboxToBbox2 = bbox => {\n  return {\n    minX: bbox.x,\n    minY: bbox.y,\n    maxX: bbox.x + bbox.width,\n    maxY: bbox.y + bbox.height\n  };\n};\nexport const bboxToBboxWithMid = box => {\n  return {\n    ...box,\n    midX: box.minX / 2 + box.maxX / 2,\n    midY: box.minY / 2 + box.maxY / 2\n  };\n};\nexport const pointsToVLines = points => {\n  const map = new Map();\n  for (const point of points) {\n    const {\n      x,\n      y\n    } = point;\n    if (!map.has(x)) {\n      map.set(x, []);\n    }\n    map.get(x).push(y);\n  }\n  return map;\n};\nexport const pointsToHLines = points => {\n  const map = new Map();\n  for (const point of points) {\n    const {\n      x,\n      y\n    } = point;\n    if (!map.has(y)) {\n      map.set(y, []);\n    }\n    map.get(y).push(x);\n  }\n  return map;\n};","map":{"version":3,"names":["DOUBLE_PI","transformRotate","getRectByTwoCoord","point1","point2","x","Math","min","y","width","abs","height","normalizeRect","x2","y2","normalizeRadian","radian","getRectsBBox","rects","length","Error","minX","map","rect","minY","maxX","max","maxY","isPointInRect","point","padding","isPointInCircle","circle","dx","dy","dSquare","radius","isRectIntersect","rect1","rect2","isRectIntersect2","isRectContain","isRectContain2","getRectCenterPoint","calcVectorRadian","cx","cy","a","b","dotProduct","d","sqrt","acos","radian2Degree","PI","degree2Radian","degree","getAbsoluteCoords","arr2point","getElementRotatedXY","element","rotation","bboxToBbox2","bbox","bboxToBboxWithMid","box","midX","midY","pointsToVLines","points","Map","has","set","get","push","pointsToHLines"],"sources":["/Users/yangdan/zf-workspace/react/suika/packages/suika/src/utils/graphics.ts"],"sourcesContent":["import { DOUBLE_PI } from '../constant';\nimport { IBox, IBox2, IBoxWithMid, ICircle, IPoint, IRect } from '../type';\nimport { transformRotate } from './transform';\n\n/**\n * 根据两个坐标点确定一个矩形\n */\nexport function getRectByTwoCoord(point1: IPoint, point2: IPoint): IRect {\n  return {\n    x: Math.min(point1.x, point2.x),\n    y: Math.min(point1.y, point2.y),\n    width: Math.abs(point1.x - point2.x),\n    height: Math.abs(point1.y - point2.y),\n  };\n}\n\n/**\n * 标准化 rect\n * 处理可能为负数的 width 和 height\n */\nexport const normalizeRect = ({ x, y, width, height }: IRect) => {\n  const x2 = x + width;\n  const y2 = y + height;\n  return getRectByTwoCoord({ x, y }, { x: x2, y: y2 });\n};\n\n/**\n * 标准化角度\n */\nexport const normalizeRadian = (radian: number): number => {\n  radian = radian % DOUBLE_PI;\n  if (radian < 0) {\n    radian += DOUBLE_PI;\n  }\n  return radian;\n};\n\n/**\n * 求多个矩形组成的包围盒\n */\nexport function getRectsBBox(...rects: IRect[]): IBox {\n  if (rects.length === 0) {\n    throw new Error('the count of rect can not be 0');\n  }\n\n  const minX = Math.min(...rects.map((rect) => rect.x));\n  const minY = Math.min(...rects.map((rect) => rect.y));\n  const maxX = Math.max(...rects.map((rect) => rect.x + rect.width));\n  const maxY = Math.max(...rects.map((rect) => rect.y + rect.height));\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n}\n\n/**\n * 点是否在矩形中\n */\nexport function isPointInRect(point: IPoint, rect: IRect, padding = 0) {\n  return (\n    point.x >= rect.x - padding &&\n    point.y >= rect.y - padding &&\n    point.x <= rect.x + rect.width + padding &&\n    point.y <= rect.y + rect.height + padding\n  );\n}\n\n/**\n * 点是否在圆形中\n */\nexport function isPointInCircle(point: IPoint, circle: ICircle) {\n  const dx = point.x - circle.x;\n  const dy = point.y - circle.y;\n  const dSquare = dx * dx + dy * dy;\n  return dSquare <= circle.radius * circle.radius;\n}\n\n/**\n * 矩形是否相交\n */\nexport function isRectIntersect(rect1: IRect, rect2: IRect) {\n  return (\n    rect1.x <= rect2.x + rect2.width &&\n    rect1.x + rect1.width >= rect2.x &&\n    rect1.y <= rect2.y + rect2.height &&\n    rect1.y + rect1.height >= rect2.y\n  );\n}\n\nexport function isRectIntersect2(rect1: IBox2, rect2: IBox2) {\n  return (\n    rect1.minX <= rect2.maxX &&\n    rect1.maxX >= rect2.minX &&\n    rect1.minY <= rect2.maxY &&\n    rect1.maxY >= rect2.minY\n  );\n}\n\n/**\n * 矩形 1 是否包含矩形 2\n */\nexport function isRectContain(rect1: IRect, rect2: IRect) {\n  return (\n    rect1.x <= rect2.x &&\n    rect1.y <= rect2.y &&\n    rect1.x + rect1.width >= rect2.x + rect2.width &&\n    rect1.y + rect1.height >= rect2.y + rect2.height\n  );\n}\n\nexport function isRectContain2(rect1: IBox2, rect2: IBox2) {\n  return (\n    rect1.minX <= rect2.minX &&\n    rect1.minY <= rect2.minY &&\n    rect1.maxX >= rect2.maxX &&\n    rect1.maxY >= rect2.maxY\n  );\n}\n\n/**\n * rect 中心点\n */\nexport function getRectCenterPoint({\n  x,\n  y,\n  width,\n  height,\n}: IRect): [cx: number, cy: number] {\n  return [x + width / 2, y + height / 2];\n}\n\n/**\n * 求向量到右侧轴(x正半轴)的夹角\n * 范围在 [0, Math.PI * 2)\n */\nexport function calcVectorRadian(cx: number, cy: number, x: number, y: number) {\n  const a = [x - cx, y - cy];\n  const b = [0, -1];\n\n  const dotProduct = a[0] * b[0] + a[1] * b[1];\n  const d =\n    Math.sqrt(a[0] * a[0] + a[1] * a[1]) * Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n  let radian = Math.acos(dotProduct / d);\n\n  if (x < cx) {\n    radian = DOUBLE_PI - radian;\n  }\n  return radian;\n}\n\n/**\n * 弧度转角度\n */\nexport function radian2Degree(radian: number) {\n  return (radian * 180) / Math.PI;\n}\n\n/**\n * 角度转弧度\n */\nexport function degree2Radian(degree: number) {\n  return (degree * Math.PI) / 180;\n}\n\n/**\n * 计算绝对坐标\n */\nexport function getAbsoluteCoords(\n  rect: IRect,\n): [x: number, y: number, x2: number, y2: number, cx: number, cy: number] {\n  return [\n    rect.x,\n    rect.y,\n    rect.x + rect.width,\n    rect.y + rect.height,\n    rect.x + rect.width / 2,\n    rect.y + rect.height / 2,\n  ];\n}\n\nexport function arr2point([x, y]: number[]): IPoint {\n  return { x, y };\n}\n\n/**\n * 计算一个形状左上角的坐标，考虑旋转\n */\nexport function getElementRotatedXY(element: {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  rotation?: number;\n}) {\n  const [cx, cy] = getRectCenterPoint(element);\n  return transformRotate(element.x, element.y, element.rotation || 0, cx, cy);\n}\n\nexport const bboxToBbox2 = (bbox: IBox): IBox2 => {\n  return {\n    minX: bbox.x,\n    minY: bbox.y,\n    maxX: bbox.x + bbox.width,\n    maxY: bbox.y + bbox.height,\n  };\n};\n\nexport const bboxToBboxWithMid = (box: IBox2): IBoxWithMid => {\n  return {\n    ...box,\n    midX: box.minX / 2 + box.maxX / 2,\n    midY: box.minY / 2 + box.maxY / 2,\n  };\n};\n\nexport const pointsToVLines = (points: IPoint[]): Map<number, number[]> => {\n  const map = new Map<number, number[]>();\n  for (const point of points) {\n    const { x, y } = point;\n    if (!map.has(x)) {\n      map.set(x, []);\n    }\n    map.get(x)!.push(y);\n  }\n  return map;\n};\n\nexport const pointsToHLines = (points: IPoint[]): Map<number, number[]> => {\n  const map = new Map<number, number[]>();\n  for (const point of points) {\n    const { x, y } = point;\n    if (!map.has(y)) {\n      map.set(y, []);\n    }\n    map.get(y)!.push(x);\n  }\n  return map;\n};\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,aAAa;AAEvC,SAASC,eAAe,QAAQ,aAAa;;AAE7C;AACA;AACA;AACA,OAAO,SAASC,iBAAiBA,CAACC,MAAc,EAAEC,MAAc,EAAS;EACvE,OAAO;IACLC,CAAC,EAAEC,IAAI,CAACC,GAAG,CAACJ,MAAM,CAACE,CAAC,EAAED,MAAM,CAACC,CAAC,CAAC;IAC/BG,CAAC,EAAEF,IAAI,CAACC,GAAG,CAACJ,MAAM,CAACK,CAAC,EAAEJ,MAAM,CAACI,CAAC,CAAC;IAC/BC,KAAK,EAAEH,IAAI,CAACI,GAAG,CAACP,MAAM,CAACE,CAAC,GAAGD,MAAM,CAACC,CAAC,CAAC;IACpCM,MAAM,EAAEL,IAAI,CAACI,GAAG,CAACP,MAAM,CAACK,CAAC,GAAGJ,MAAM,CAACI,CAAC;EACtC,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAMI,aAAa,GAAGA,CAAC;EAAEP,CAAC;EAAEG,CAAC;EAAEC,KAAK;EAAEE;AAAc,CAAC,KAAK;EAC/D,MAAME,EAAE,GAAGR,CAAC,GAAGI,KAAK;EACpB,MAAMK,EAAE,GAAGN,CAAC,GAAGG,MAAM;EACrB,OAAOT,iBAAiB,CAAC;IAAEG,CAAC;IAAEG;EAAE,CAAC,EAAE;IAAEH,CAAC,EAAEQ,EAAE;IAAEL,CAAC,EAAEM;EAAG,CAAC,CAAC;AACtD,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAIC,MAAc,IAAa;EACzDA,MAAM,GAAGA,MAAM,GAAGhB,SAAS;EAC3B,IAAIgB,MAAM,GAAG,CAAC,EAAE;IACdA,MAAM,IAAIhB,SAAS;EACrB;EACA,OAAOgB,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAAC,GAAGC,KAAc,EAAQ;EACpD,IAAIA,KAAK,CAACC,MAAM,KAAK,CAAC,EAAE;IACtB,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;EACnD;EAEA,MAAMC,IAAI,GAAGf,IAAI,CAACC,GAAG,CAAC,GAAGW,KAAK,CAACI,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAAClB,CAAC,CAAC,CAAC;EACrD,MAAMmB,IAAI,GAAGlB,IAAI,CAACC,GAAG,CAAC,GAAGW,KAAK,CAACI,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAACf,CAAC,CAAC,CAAC;EACrD,MAAMiB,IAAI,GAAGnB,IAAI,CAACoB,GAAG,CAAC,GAAGR,KAAK,CAACI,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAAClB,CAAC,GAAGkB,IAAI,CAACd,KAAK,CAAC,CAAC;EAClE,MAAMkB,IAAI,GAAGrB,IAAI,CAACoB,GAAG,CAAC,GAAGR,KAAK,CAACI,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAACf,CAAC,GAAGe,IAAI,CAACZ,MAAM,CAAC,CAAC;EAEnE,OAAO;IACLN,CAAC,EAAEgB,IAAI;IACPb,CAAC,EAAEgB,IAAI;IACPf,KAAK,EAAEgB,IAAI,GAAGJ,IAAI;IAClBV,MAAM,EAAEgB,IAAI,GAAGH;EACjB,CAAC;AACH;;AAEA;AACA;AACA;AACA,OAAO,SAASI,aAAaA,CAACC,KAAa,EAAEN,IAAW,EAAEO,OAAO,GAAG,CAAC,EAAE;EACrE,OACED,KAAK,CAACxB,CAAC,IAAIkB,IAAI,CAAClB,CAAC,GAAGyB,OAAO,IAC3BD,KAAK,CAACrB,CAAC,IAAIe,IAAI,CAACf,CAAC,GAAGsB,OAAO,IAC3BD,KAAK,CAACxB,CAAC,IAAIkB,IAAI,CAAClB,CAAC,GAAGkB,IAAI,CAACd,KAAK,GAAGqB,OAAO,IACxCD,KAAK,CAACrB,CAAC,IAAIe,IAAI,CAACf,CAAC,GAAGe,IAAI,CAACZ,MAAM,GAAGmB,OAAO;AAE7C;;AAEA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACF,KAAa,EAAEG,MAAe,EAAE;EAC9D,MAAMC,EAAE,GAAGJ,KAAK,CAACxB,CAAC,GAAG2B,MAAM,CAAC3B,CAAC;EAC7B,MAAM6B,EAAE,GAAGL,KAAK,CAACrB,CAAC,GAAGwB,MAAM,CAACxB,CAAC;EAC7B,MAAM2B,OAAO,GAAGF,EAAE,GAAGA,EAAE,GAAGC,EAAE,GAAGA,EAAE;EACjC,OAAOC,OAAO,IAAIH,MAAM,CAACI,MAAM,GAAGJ,MAAM,CAACI,MAAM;AACjD;;AAEA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACC,KAAY,EAAEC,KAAY,EAAE;EAC1D,OACED,KAAK,CAACjC,CAAC,IAAIkC,KAAK,CAAClC,CAAC,GAAGkC,KAAK,CAAC9B,KAAK,IAChC6B,KAAK,CAACjC,CAAC,GAAGiC,KAAK,CAAC7B,KAAK,IAAI8B,KAAK,CAAClC,CAAC,IAChCiC,KAAK,CAAC9B,CAAC,IAAI+B,KAAK,CAAC/B,CAAC,GAAG+B,KAAK,CAAC5B,MAAM,IACjC2B,KAAK,CAAC9B,CAAC,GAAG8B,KAAK,CAAC3B,MAAM,IAAI4B,KAAK,CAAC/B,CAAC;AAErC;AAEA,OAAO,SAASgC,gBAAgBA,CAACF,KAAY,EAAEC,KAAY,EAAE;EAC3D,OACED,KAAK,CAACjB,IAAI,IAAIkB,KAAK,CAACd,IAAI,IACxBa,KAAK,CAACb,IAAI,IAAIc,KAAK,CAAClB,IAAI,IACxBiB,KAAK,CAACd,IAAI,IAAIe,KAAK,CAACZ,IAAI,IACxBW,KAAK,CAACX,IAAI,IAAIY,KAAK,CAACf,IAAI;AAE5B;;AAEA;AACA;AACA;AACA,OAAO,SAASiB,aAAaA,CAACH,KAAY,EAAEC,KAAY,EAAE;EACxD,OACED,KAAK,CAACjC,CAAC,IAAIkC,KAAK,CAAClC,CAAC,IAClBiC,KAAK,CAAC9B,CAAC,IAAI+B,KAAK,CAAC/B,CAAC,IAClB8B,KAAK,CAACjC,CAAC,GAAGiC,KAAK,CAAC7B,KAAK,IAAI8B,KAAK,CAAClC,CAAC,GAAGkC,KAAK,CAAC9B,KAAK,IAC9C6B,KAAK,CAAC9B,CAAC,GAAG8B,KAAK,CAAC3B,MAAM,IAAI4B,KAAK,CAAC/B,CAAC,GAAG+B,KAAK,CAAC5B,MAAM;AAEpD;AAEA,OAAO,SAAS+B,cAAcA,CAACJ,KAAY,EAAEC,KAAY,EAAE;EACzD,OACED,KAAK,CAACjB,IAAI,IAAIkB,KAAK,CAAClB,IAAI,IACxBiB,KAAK,CAACd,IAAI,IAAIe,KAAK,CAACf,IAAI,IACxBc,KAAK,CAACb,IAAI,IAAIc,KAAK,CAACd,IAAI,IACxBa,KAAK,CAACX,IAAI,IAAIY,KAAK,CAACZ,IAAI;AAE5B;;AAEA;AACA;AACA;AACA,OAAO,SAASgB,kBAAkBA,CAAC;EACjCtC,CAAC;EACDG,CAAC;EACDC,KAAK;EACLE;AACK,CAAC,EAA4B;EAClC,OAAO,CAACN,CAAC,GAAGI,KAAK,GAAG,CAAC,EAAED,CAAC,GAAGG,MAAM,GAAG,CAAC,CAAC;AACxC;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASiC,gBAAgBA,CAACC,EAAU,EAAEC,EAAU,EAAEzC,CAAS,EAAEG,CAAS,EAAE;EAC7E,MAAMuC,CAAC,GAAG,CAAC1C,CAAC,GAAGwC,EAAE,EAAErC,CAAC,GAAGsC,EAAE,CAAC;EAC1B,MAAME,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAEjB,MAAMC,UAAU,GAAGF,CAAC,CAAC,CAAC,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC,GAAGD,CAAC,CAAC,CAAC,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC;EAC5C,MAAME,CAAC,GACL5C,IAAI,CAAC6C,IAAI,CAACJ,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGzC,IAAI,CAAC6C,IAAI,CAACH,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAAC;EAC7E,IAAIhC,MAAM,GAAGV,IAAI,CAAC8C,IAAI,CAACH,UAAU,GAAGC,CAAC,CAAC;EAEtC,IAAI7C,CAAC,GAAGwC,EAAE,EAAE;IACV7B,MAAM,GAAGhB,SAAS,GAAGgB,MAAM;EAC7B;EACA,OAAOA,MAAM;AACf;;AAEA;AACA;AACA;AACA,OAAO,SAASqC,aAAaA,CAACrC,MAAc,EAAE;EAC5C,OAAQA,MAAM,GAAG,GAAG,GAAIV,IAAI,CAACgD,EAAE;AACjC;;AAEA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAACC,MAAc,EAAE;EAC5C,OAAQA,MAAM,GAAGlD,IAAI,CAACgD,EAAE,GAAI,GAAG;AACjC;;AAEA;AACA;AACA;AACA,OAAO,SAASG,iBAAiBA,CAC/BlC,IAAW,EAC6D;EACxE,OAAO,CACLA,IAAI,CAAClB,CAAC,EACNkB,IAAI,CAACf,CAAC,EACNe,IAAI,CAAClB,CAAC,GAAGkB,IAAI,CAACd,KAAK,EACnBc,IAAI,CAACf,CAAC,GAAGe,IAAI,CAACZ,MAAM,EACpBY,IAAI,CAAClB,CAAC,GAAGkB,IAAI,CAACd,KAAK,GAAG,CAAC,EACvBc,IAAI,CAACf,CAAC,GAAGe,IAAI,CAACZ,MAAM,GAAG,CAAC,CACzB;AACH;AAEA,OAAO,SAAS+C,SAASA,CAAC,CAACrD,CAAC,EAAEG,CAAC,CAAW,EAAU;EAClD,OAAO;IAAEH,CAAC;IAAEG;EAAE,CAAC;AACjB;;AAEA;AACA;AACA;AACA,OAAO,SAASmD,mBAAmBA,CAACC,OAMnC,EAAE;EACD,MAAM,CAACf,EAAE,EAAEC,EAAE,CAAC,GAAGH,kBAAkB,CAACiB,OAAO,CAAC;EAC5C,OAAO3D,eAAe,CAAC2D,OAAO,CAACvD,CAAC,EAAEuD,OAAO,CAACpD,CAAC,EAAEoD,OAAO,CAACC,QAAQ,IAAI,CAAC,EAAEhB,EAAE,EAAEC,EAAE,CAAC;AAC7E;AAEA,OAAO,MAAMgB,WAAW,GAAIC,IAAU,IAAY;EAChD,OAAO;IACL1C,IAAI,EAAE0C,IAAI,CAAC1D,CAAC;IACZmB,IAAI,EAAEuC,IAAI,CAACvD,CAAC;IACZiB,IAAI,EAAEsC,IAAI,CAAC1D,CAAC,GAAG0D,IAAI,CAACtD,KAAK;IACzBkB,IAAI,EAAEoC,IAAI,CAACvD,CAAC,GAAGuD,IAAI,CAACpD;EACtB,CAAC;AACH,CAAC;AAED,OAAO,MAAMqD,iBAAiB,GAAIC,GAAU,IAAkB;EAC5D,OAAO;IACL,GAAGA,GAAG;IACNC,IAAI,EAAED,GAAG,CAAC5C,IAAI,GAAG,CAAC,GAAG4C,GAAG,CAACxC,IAAI,GAAG,CAAC;IACjC0C,IAAI,EAAEF,GAAG,CAACzC,IAAI,GAAG,CAAC,GAAGyC,GAAG,CAACtC,IAAI,GAAG;EAClC,CAAC;AACH,CAAC;AAED,OAAO,MAAMyC,cAAc,GAAIC,MAAgB,IAA4B;EACzE,MAAM/C,GAAG,GAAG,IAAIgD,GAAG,CAAmB,CAAC;EACvC,KAAK,MAAMzC,KAAK,IAAIwC,MAAM,EAAE;IAC1B,MAAM;MAAEhE,CAAC;MAAEG;IAAE,CAAC,GAAGqB,KAAK;IACtB,IAAI,CAACP,GAAG,CAACiD,GAAG,CAAClE,CAAC,CAAC,EAAE;MACfiB,GAAG,CAACkD,GAAG,CAACnE,CAAC,EAAE,EAAE,CAAC;IAChB;IACAiB,GAAG,CAACmD,GAAG,CAACpE,CAAC,CAAC,CAAEqE,IAAI,CAAClE,CAAC,CAAC;EACrB;EACA,OAAOc,GAAG;AACZ,CAAC;AAED,OAAO,MAAMqD,cAAc,GAAIN,MAAgB,IAA4B;EACzE,MAAM/C,GAAG,GAAG,IAAIgD,GAAG,CAAmB,CAAC;EACvC,KAAK,MAAMzC,KAAK,IAAIwC,MAAM,EAAE;IAC1B,MAAM;MAAEhE,CAAC;MAAEG;IAAE,CAAC,GAAGqB,KAAK;IACtB,IAAI,CAACP,GAAG,CAACiD,GAAG,CAAC/D,CAAC,CAAC,EAAE;MACfc,GAAG,CAACkD,GAAG,CAAChE,CAAC,EAAE,EAAE,CAAC;IAChB;IACAc,GAAG,CAACmD,GAAG,CAACjE,CAAC,CAAC,CAAEkE,IAAI,CAACrE,CAAC,CAAC;EACrB;EACA,OAAOiB,GAAG;AACZ,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}