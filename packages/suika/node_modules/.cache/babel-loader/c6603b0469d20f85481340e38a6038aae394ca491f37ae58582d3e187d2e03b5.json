{"ast":null,"code":"import { useRef } from 'react';\nimport useUpdateEffect from '../../../useUpdateEffect';\nimport isDocumentVisible from '../utils/isDocumentVisible';\nimport subscribeReVisible from '../utils/subscribeReVisible';\nconst usePollingPlugin = (fetchInstance, {\n  pollingInterval,\n  pollingWhenHidden = true,\n  pollingErrorRetryCount = -1\n}) => {\n  const timerRef = useRef();\n  const unsubscribeRef = useRef();\n  const countRef = useRef(0);\n  const stopPolling = () => {\n    var _a;\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n    }\n    (_a = unsubscribeRef.current) === null || _a === void 0 ? void 0 : _a.call(unsubscribeRef);\n  };\n  useUpdateEffect(() => {\n    if (!pollingInterval) {\n      stopPolling();\n    }\n  }, [pollingInterval]);\n  if (!pollingInterval) {\n    return {};\n  }\n  return {\n    onBefore: () => {\n      stopPolling();\n    },\n    onError: () => {\n      countRef.current += 1;\n    },\n    onSuccess: () => {\n      countRef.current = 0;\n    },\n    onFinally: () => {\n      if (pollingErrorRetryCount === -1 ||\n      // When an error occurs, the request is not repeated after pollingErrorRetryCount retries\n      pollingErrorRetryCount !== -1 && countRef.current <= pollingErrorRetryCount) {\n        timerRef.current = setTimeout(() => {\n          // if pollingWhenHidden = false && document is hidden, then stop polling and subscribe revisible\n          if (!pollingWhenHidden && !isDocumentVisible()) {\n            unsubscribeRef.current = subscribeReVisible(() => {\n              fetchInstance.refresh();\n            });\n          } else {\n            fetchInstance.refresh();\n          }\n        }, pollingInterval);\n      } else {\n        countRef.current = 0;\n      }\n    },\n    onCancel: () => {\n      stopPolling();\n    }\n  };\n};\nexport default usePollingPlugin;","map":{"version":3,"names":["useRef","useUpdateEffect","isDocumentVisible","subscribeReVisible","usePollingPlugin","fetchInstance","pollingInterval","pollingWhenHidden","pollingErrorRetryCount","timerRef","unsubscribeRef","countRef","stopPolling","_a","current","clearTimeout","call","onBefore","onError","onSuccess","onFinally","setTimeout","refresh","onCancel"],"sources":["/Users/yangdan/zf-workspace/react/suika/node_modules/.pnpm/registry.npmmirror.com+ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/plugins/usePollingPlugin.js"],"sourcesContent":["import { useRef } from 'react';\nimport useUpdateEffect from '../../../useUpdateEffect';\nimport isDocumentVisible from '../utils/isDocumentVisible';\nimport subscribeReVisible from '../utils/subscribeReVisible';\nconst usePollingPlugin = (fetchInstance, {\n  pollingInterval,\n  pollingWhenHidden = true,\n  pollingErrorRetryCount = -1\n}) => {\n  const timerRef = useRef();\n  const unsubscribeRef = useRef();\n  const countRef = useRef(0);\n  const stopPolling = () => {\n    var _a;\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n    }\n    (_a = unsubscribeRef.current) === null || _a === void 0 ? void 0 : _a.call(unsubscribeRef);\n  };\n  useUpdateEffect(() => {\n    if (!pollingInterval) {\n      stopPolling();\n    }\n  }, [pollingInterval]);\n  if (!pollingInterval) {\n    return {};\n  }\n  return {\n    onBefore: () => {\n      stopPolling();\n    },\n    onError: () => {\n      countRef.current += 1;\n    },\n    onSuccess: () => {\n      countRef.current = 0;\n    },\n    onFinally: () => {\n      if (pollingErrorRetryCount === -1 ||\n      // When an error occurs, the request is not repeated after pollingErrorRetryCount retries\n      pollingErrorRetryCount !== -1 && countRef.current <= pollingErrorRetryCount) {\n        timerRef.current = setTimeout(() => {\n          // if pollingWhenHidden = false && document is hidden, then stop polling and subscribe revisible\n          if (!pollingWhenHidden && !isDocumentVisible()) {\n            unsubscribeRef.current = subscribeReVisible(() => {\n              fetchInstance.refresh();\n            });\n          } else {\n            fetchInstance.refresh();\n          }\n        }, pollingInterval);\n      } else {\n        countRef.current = 0;\n      }\n    },\n    onCancel: () => {\n      stopPolling();\n    }\n  };\n};\nexport default usePollingPlugin;"],"mappings":"AAAA,SAASA,MAAM,QAAQ,OAAO;AAC9B,OAAOC,eAAe,MAAM,0BAA0B;AACtD,OAAOC,iBAAiB,MAAM,4BAA4B;AAC1D,OAAOC,kBAAkB,MAAM,6BAA6B;AAC5D,MAAMC,gBAAgB,GAAGA,CAACC,aAAa,EAAE;EACvCC,eAAe;EACfC,iBAAiB,GAAG,IAAI;EACxBC,sBAAsB,GAAG,CAAC;AAC5B,CAAC,KAAK;EACJ,MAAMC,QAAQ,GAAGT,MAAM,CAAC,CAAC;EACzB,MAAMU,cAAc,GAAGV,MAAM,CAAC,CAAC;EAC/B,MAAMW,QAAQ,GAAGX,MAAM,CAAC,CAAC,CAAC;EAC1B,MAAMY,WAAW,GAAGA,CAAA,KAAM;IACxB,IAAIC,EAAE;IACN,IAAIJ,QAAQ,CAACK,OAAO,EAAE;MACpBC,YAAY,CAACN,QAAQ,CAACK,OAAO,CAAC;IAChC;IACA,CAACD,EAAE,GAAGH,cAAc,CAACI,OAAO,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACG,IAAI,CAACN,cAAc,CAAC;EAC5F,CAAC;EACDT,eAAe,CAAC,MAAM;IACpB,IAAI,CAACK,eAAe,EAAE;MACpBM,WAAW,CAAC,CAAC;IACf;EACF,CAAC,EAAE,CAACN,eAAe,CAAC,CAAC;EACrB,IAAI,CAACA,eAAe,EAAE;IACpB,OAAO,CAAC,CAAC;EACX;EACA,OAAO;IACLW,QAAQ,EAAEA,CAAA,KAAM;MACdL,WAAW,CAAC,CAAC;IACf,CAAC;IACDM,OAAO,EAAEA,CAAA,KAAM;MACbP,QAAQ,CAACG,OAAO,IAAI,CAAC;IACvB,CAAC;IACDK,SAAS,EAAEA,CAAA,KAAM;MACfR,QAAQ,CAACG,OAAO,GAAG,CAAC;IACtB,CAAC;IACDM,SAAS,EAAEA,CAAA,KAAM;MACf,IAAIZ,sBAAsB,KAAK,CAAC,CAAC;MACjC;MACAA,sBAAsB,KAAK,CAAC,CAAC,IAAIG,QAAQ,CAACG,OAAO,IAAIN,sBAAsB,EAAE;QAC3EC,QAAQ,CAACK,OAAO,GAAGO,UAAU,CAAC,MAAM;UAClC;UACA,IAAI,CAACd,iBAAiB,IAAI,CAACL,iBAAiB,CAAC,CAAC,EAAE;YAC9CQ,cAAc,CAACI,OAAO,GAAGX,kBAAkB,CAAC,MAAM;cAChDE,aAAa,CAACiB,OAAO,CAAC,CAAC;YACzB,CAAC,CAAC;UACJ,CAAC,MAAM;YACLjB,aAAa,CAACiB,OAAO,CAAC,CAAC;UACzB;QACF,CAAC,EAAEhB,eAAe,CAAC;MACrB,CAAC,MAAM;QACLK,QAAQ,CAACG,OAAO,GAAG,CAAC;MACtB;IACF,CAAC;IACDS,QAAQ,EAAEA,CAAA,KAAM;MACdX,WAAW,CAAC,CAAC;IACf;EACF,CAAC;AACH,CAAC;AACD,eAAeR,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}