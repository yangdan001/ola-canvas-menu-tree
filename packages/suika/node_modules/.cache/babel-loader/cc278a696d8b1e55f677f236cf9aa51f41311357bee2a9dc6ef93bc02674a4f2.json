{"ast":null,"code":"import { firstInfoOfUnmovedGraphs, lastInfoOfUnmovedGraphs } from './util';\nexport let ArrangeType = /*#__PURE__*/function (ArrangeType) {\n  ArrangeType[\"Front\"] = \"Front\";\n  ArrangeType[\"Back\"] = \"Back\";\n  ArrangeType[\"Forward\"] = \"Forward\";\n  ArrangeType[\"Backward\"] = \"Backward\";\n  return ArrangeType;\n}({});\nexport class ArrangeCmd {\n  // TODO: optimize space complexity\n  constructor(desc, editor,\n  /**\n   * it's no need to keep right relative order\n   */\n  movedGraphs, type) {\n    this.desc = desc;\n    this.editor = editor;\n    this.type = type;\n    this.movedGraphSet = void 0;\n    this.prevGraphs = [];\n    if (movedGraphs.length === 0) {\n      throw new Error(\"can't arrange, no element\");\n    }\n    const movedGraphSet = this.movedGraphSet = new Set(movedGraphs);\n    if (movedGraphSet.size !== movedGraphs.length) {\n      console.warn('the arg \"movedGraphs\" in ArrangeCmd constructor has duplicate values');\n    }\n    this.do();\n  }\n  do() {\n    const graphs = this.editor.sceneGraph.children;\n    this.prevGraphs = graphs;\n    switch (this.type) {\n      case ArrangeType.Front:\n        {\n          this.editor.sceneGraph.children = front(graphs, this.movedGraphSet);\n          break;\n        }\n      case ArrangeType.Forward:\n        {\n          this.editor.sceneGraph.children = forward(graphs, this.movedGraphSet);\n          break;\n        }\n      case ArrangeType.Backward:\n        {\n          this.editor.sceneGraph.children = backward(graphs, this.movedGraphSet);\n          break;\n        }\n      case ArrangeType.Back:\n        {\n          this.editor.sceneGraph.children = back(graphs, this.movedGraphSet);\n          break;\n        }\n    }\n  }\n  redo() {\n    this.do();\n  }\n  undo() {\n    this.editor.sceneGraph.children = this.prevGraphs;\n  }\n  static shouldExecCmd(type, graphs, movedGraphSet) {\n    if (graphs.length === 0 || movedGraphSet.size === 0 || movedGraphSet.size === graphs.length) {\n      return false;\n    }\n    switch (type) {\n      case ArrangeType.Front:\n      case ArrangeType.Forward:\n        {\n          // ps: the last element in the array is the top element in the canvas\n          const {\n            count\n          } = lastInfoOfUnmovedGraphs(graphs, movedGraphSet);\n          if (count === movedGraphSet.size) return false;\n          break;\n        }\n      case ArrangeType.Back:\n      case ArrangeType.Backward:\n        {\n          const {\n            count\n          } = firstInfoOfUnmovedGraphs(graphs, movedGraphSet);\n          if (count === movedGraphSet.size) return false;\n          break;\n        }\n    }\n    return true;\n  }\n}\nconst front = (graphs, movedGraphSet) => {\n  const newGraphs = [];\n  const tailGraphs = [];\n  for (let i = 0; i < graphs.length; i++) {\n    const graph = graphs[i];\n    if (movedGraphSet.has(graph)) {\n      tailGraphs.push(graph);\n    } else {\n      newGraphs.push(graph);\n    }\n  }\n  newGraphs.push(...tailGraphs);\n  return newGraphs;\n};\nconst back = (graphs, movedGraphSet) => {\n  const newGraphs = [];\n  const tailGraphs = [];\n  for (let i = graphs.length - 1; i >= 0; i--) {\n    const graph = graphs[i];\n    if (movedGraphSet.has(graph)) {\n      tailGraphs.push(graph);\n    } else {\n      newGraphs.push(graph);\n    }\n  }\n  newGraphs.push(...tailGraphs);\n  return newGraphs.reverse(); // reverse\n};\n\nconst forward = (graphs, movedGraphs) => {\n  const newGraphs = [...graphs];\n  let i = lastInfoOfUnmovedGraphs(newGraphs, movedGraphs).index;\n  for (; i >= 0; i--) {\n    if (movedGraphs.has(newGraphs[i])) {\n      [newGraphs[i], newGraphs[i + 1]] = [newGraphs[i + 1], newGraphs[i]];\n    }\n  }\n  return newGraphs;\n};\nconst backward = (graphs, movedGraphs) => {\n  const newGraphs = [...graphs];\n  let i = firstInfoOfUnmovedGraphs(newGraphs, movedGraphs).index;\n  for (; i < newGraphs.length; i++) {\n    if (movedGraphs.has(newGraphs[i])) {\n      [newGraphs[i], newGraphs[i - 1]] = [newGraphs[i - 1], newGraphs[i]];\n    }\n  }\n  return newGraphs;\n};","map":{"version":3,"names":["firstInfoOfUnmovedGraphs","lastInfoOfUnmovedGraphs","ArrangeType","ArrangeCmd","constructor","desc","editor","movedGraphs","type","movedGraphSet","prevGraphs","length","Error","Set","size","console","warn","do","graphs","sceneGraph","children","Front","front","Forward","forward","Backward","backward","Back","back","redo","undo","shouldExecCmd","count","newGraphs","tailGraphs","i","graph","has","push","reverse","index"],"sources":["/Users/yangdan/zf-workspace/react/suika/packages/suika/src/editor/commands/arrange/arrange.ts"],"sourcesContent":["import { Editor } from '../../editor';\nimport { Graph } from '../../scene/graph';\nimport { ICommand } from '../type';\nimport { firstInfoOfUnmovedGraphs, lastInfoOfUnmovedGraphs } from './util';\n\nexport enum ArrangeType {\n  Front = 'Front',\n  Back = 'Back',\n  Forward = 'Forward',\n  Backward = 'Backward',\n}\n\nexport class ArrangeCmd implements ICommand {\n  private movedGraphSet: Set<Graph>;\n  private prevGraphs: Graph[] = []; // TODO: optimize space complexity\n  constructor(\n    public desc: string,\n    private editor: Editor,\n    /**\n     * it's no need to keep right relative order\n     */\n    movedGraphs: Graph[],\n    public type: ArrangeType,\n  ) {\n    if (movedGraphs.length === 0) {\n      throw new Error(\"can't arrange, no element\");\n    }\n\n    const movedGraphSet = (this.movedGraphSet = new Set(movedGraphs));\n    if (movedGraphSet.size !== movedGraphs.length) {\n      console.warn(\n        'the arg \"movedGraphs\" in ArrangeCmd constructor has duplicate values',\n      );\n    }\n\n    this.do();\n  }\n  do() {\n    const graphs = this.editor.sceneGraph.children;\n    this.prevGraphs = graphs;\n    switch (this.type) {\n      case ArrangeType.Front: {\n        this.editor.sceneGraph.children = front(graphs, this.movedGraphSet);\n        break;\n      }\n      case ArrangeType.Forward: {\n        this.editor.sceneGraph.children = forward(graphs, this.movedGraphSet);\n        break;\n      }\n      case ArrangeType.Backward: {\n        this.editor.sceneGraph.children = backward(graphs, this.movedGraphSet);\n        break;\n      }\n      case ArrangeType.Back: {\n        this.editor.sceneGraph.children = back(graphs, this.movedGraphSet);\n        break;\n      }\n    }\n  }\n  redo() {\n    this.do();\n  }\n  undo() {\n    this.editor.sceneGraph.children = this.prevGraphs;\n  }\n  static shouldExecCmd(\n    type: ArrangeType,\n    graphs: Graph[],\n    movedGraphSet: Set<Graph>,\n  ): boolean {\n    if (\n      graphs.length === 0 ||\n      movedGraphSet.size === 0 ||\n      movedGraphSet.size === graphs.length\n    ) {\n      return false;\n    }\n\n    switch (type) {\n      case ArrangeType.Front:\n      case ArrangeType.Forward: {\n        // ps: the last element in the array is the top element in the canvas\n        const { count } = lastInfoOfUnmovedGraphs(graphs, movedGraphSet);\n        if (count === movedGraphSet.size) return false;\n        break;\n      }\n      case ArrangeType.Back:\n      case ArrangeType.Backward: {\n        const { count } = firstInfoOfUnmovedGraphs(graphs, movedGraphSet);\n        if (count === movedGraphSet.size) return false;\n        break;\n      }\n    }\n\n    return true;\n  }\n}\n\nconst front = (graphs: Graph[], movedGraphSet: Set<Graph>) => {\n  const newGraphs: Graph[] = [];\n  const tailGraphs: Graph[] = [];\n  for (let i = 0; i < graphs.length; i++) {\n    const graph = graphs[i];\n    if (movedGraphSet.has(graph)) {\n      tailGraphs.push(graph);\n    } else {\n      newGraphs.push(graph);\n    }\n  }\n  newGraphs.push(...tailGraphs);\n  return newGraphs;\n};\n\nconst back = (graphs: Graph[], movedGraphSet: Set<Graph>) => {\n  const newGraphs: Graph[] = [];\n  const tailGraphs: Graph[] = [];\n  for (let i = graphs.length - 1; i >= 0; i--) {\n    const graph = graphs[i];\n    if (movedGraphSet.has(graph)) {\n      tailGraphs.push(graph);\n    } else {\n      newGraphs.push(graph);\n    }\n  }\n  newGraphs.push(...tailGraphs);\n  return newGraphs.reverse(); // reverse\n};\n\nconst forward = (graphs: Graph[], movedGraphs: Set<Graph>) => {\n  const newGraphs = [...graphs];\n\n  let i = lastInfoOfUnmovedGraphs(newGraphs, movedGraphs).index;\n\n  for (; i >= 0; i--) {\n    if (movedGraphs.has(newGraphs[i])) {\n      [newGraphs[i], newGraphs[i + 1]] = [newGraphs[i + 1], newGraphs[i]];\n    }\n  }\n  return newGraphs;\n};\n\nconst backward = (graphs: Graph[], movedGraphs: Set<Graph>) => {\n  const newGraphs = [...graphs];\n\n  let i = firstInfoOfUnmovedGraphs(newGraphs, movedGraphs).index;\n\n  for (; i < newGraphs.length; i++) {\n    if (movedGraphs.has(newGraphs[i])) {\n      [newGraphs[i], newGraphs[i - 1]] = [newGraphs[i - 1], newGraphs[i]];\n    }\n  }\n  return newGraphs;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}