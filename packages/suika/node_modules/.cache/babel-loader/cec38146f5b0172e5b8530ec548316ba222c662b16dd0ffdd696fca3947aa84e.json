{"ast":null,"code":"import { useEffect, useMemo, useState, useRef } from 'react';\nimport useEventListener from '../useEventListener';\nimport useLatest from '../useLatest';\nimport useMemoizedFn from '../useMemoizedFn';\nimport useSize from '../useSize';\nimport { getTargetElement } from '../utils/domTarget';\nimport { isNumber } from '../utils';\nconst useVirtualList = (list, options) => {\n  const {\n    containerTarget,\n    wrapperTarget,\n    itemHeight,\n    overscan = 5\n  } = options;\n  const itemHeightRef = useLatest(itemHeight);\n  const size = useSize(containerTarget);\n  const scrollTriggerByScrollToFunc = useRef(false);\n  const [targetList, setTargetList] = useState([]);\n  const getVisibleCount = (containerHeight, fromIndex) => {\n    if (isNumber(itemHeightRef.current)) {\n      return Math.ceil(containerHeight / itemHeightRef.current);\n    }\n    let sum = 0;\n    let endIndex = 0;\n    for (let i = fromIndex; i < list.length; i++) {\n      const height = itemHeightRef.current(i, list[i]);\n      sum += height;\n      endIndex = i;\n      if (sum >= containerHeight) {\n        break;\n      }\n    }\n    return endIndex - fromIndex;\n  };\n  const getOffset = scrollTop => {\n    if (isNumber(itemHeightRef.current)) {\n      return Math.floor(scrollTop / itemHeightRef.current) + 1;\n    }\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < list.length; i++) {\n      const height = itemHeightRef.current(i, list[i]);\n      sum += height;\n      if (sum >= scrollTop) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n  // 获取上部高度\n  const getDistanceTop = index => {\n    if (isNumber(itemHeightRef.current)) {\n      const height = index * itemHeightRef.current;\n      return height;\n    }\n    const height = list.slice(0, index).reduce((sum, _, i) => sum + itemHeightRef.current(i, list[i]), 0);\n    return height;\n  };\n  const totalHeight = useMemo(() => {\n    if (isNumber(itemHeightRef.current)) {\n      return list.length * itemHeightRef.current;\n    }\n    return list.reduce((sum, _, index) => sum + itemHeightRef.current(index, list[index]), 0);\n  }, [list]);\n  const calculateRange = () => {\n    const container = getTargetElement(containerTarget);\n    const wrapper = getTargetElement(wrapperTarget);\n    if (container && wrapper) {\n      const {\n        scrollTop,\n        clientHeight\n      } = container;\n      const offset = getOffset(scrollTop);\n      const visibleCount = getVisibleCount(clientHeight, offset);\n      const start = Math.max(0, offset - overscan);\n      const end = Math.min(list.length, offset + visibleCount + overscan);\n      const offsetTop = getDistanceTop(start);\n      wrapper.style.height = totalHeight - offsetTop + 'px';\n      wrapper.style.marginTop = offsetTop + 'px';\n      setTargetList(list.slice(start, end).map((ele, index) => ({\n        data: ele,\n        index: index + start\n      })));\n    }\n  };\n  useEffect(() => {\n    if (!(size === null || size === void 0 ? void 0 : size.width) || !(size === null || size === void 0 ? void 0 : size.height)) {\n      return;\n    }\n    calculateRange();\n  }, [size === null || size === void 0 ? void 0 : size.width, size === null || size === void 0 ? void 0 : size.height, list]);\n  useEventListener('scroll', e => {\n    if (scrollTriggerByScrollToFunc.current) {\n      scrollTriggerByScrollToFunc.current = false;\n      return;\n    }\n    e.preventDefault();\n    calculateRange();\n  }, {\n    target: containerTarget\n  });\n  const scrollTo = index => {\n    const container = getTargetElement(containerTarget);\n    if (container) {\n      scrollTriggerByScrollToFunc.current = true;\n      container.scrollTop = getDistanceTop(index);\n      calculateRange();\n    }\n  };\n  return [targetList, useMemoizedFn(scrollTo)];\n};\nexport default useVirtualList;","map":{"version":3,"names":["useEffect","useMemo","useState","useRef","useEventListener","useLatest","useMemoizedFn","useSize","getTargetElement","isNumber","useVirtualList","list","options","containerTarget","wrapperTarget","itemHeight","overscan","itemHeightRef","size","scrollTriggerByScrollToFunc","targetList","setTargetList","getVisibleCount","containerHeight","fromIndex","current","Math","ceil","sum","endIndex","i","length","height","getOffset","scrollTop","floor","offset","getDistanceTop","index","slice","reduce","_","totalHeight","calculateRange","container","wrapper","clientHeight","visibleCount","start","max","end","min","offsetTop","style","marginTop","map","ele","data","width","e","preventDefault","target","scrollTo"],"sources":["/Users/yangdan/zf-workspace/react/suika/node_modules/.pnpm/registry.npmmirror.com+ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useVirtualList/index.js"],"sourcesContent":["import { useEffect, useMemo, useState, useRef } from 'react';\nimport useEventListener from '../useEventListener';\nimport useLatest from '../useLatest';\nimport useMemoizedFn from '../useMemoizedFn';\nimport useSize from '../useSize';\nimport { getTargetElement } from '../utils/domTarget';\nimport { isNumber } from '../utils';\nconst useVirtualList = (list, options) => {\n  const {\n    containerTarget,\n    wrapperTarget,\n    itemHeight,\n    overscan = 5\n  } = options;\n  const itemHeightRef = useLatest(itemHeight);\n  const size = useSize(containerTarget);\n  const scrollTriggerByScrollToFunc = useRef(false);\n  const [targetList, setTargetList] = useState([]);\n  const getVisibleCount = (containerHeight, fromIndex) => {\n    if (isNumber(itemHeightRef.current)) {\n      return Math.ceil(containerHeight / itemHeightRef.current);\n    }\n    let sum = 0;\n    let endIndex = 0;\n    for (let i = fromIndex; i < list.length; i++) {\n      const height = itemHeightRef.current(i, list[i]);\n      sum += height;\n      endIndex = i;\n      if (sum >= containerHeight) {\n        break;\n      }\n    }\n    return endIndex - fromIndex;\n  };\n  const getOffset = scrollTop => {\n    if (isNumber(itemHeightRef.current)) {\n      return Math.floor(scrollTop / itemHeightRef.current) + 1;\n    }\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < list.length; i++) {\n      const height = itemHeightRef.current(i, list[i]);\n      sum += height;\n      if (sum >= scrollTop) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n  // 获取上部高度\n  const getDistanceTop = index => {\n    if (isNumber(itemHeightRef.current)) {\n      const height = index * itemHeightRef.current;\n      return height;\n    }\n    const height = list.slice(0, index).reduce((sum, _, i) => sum + itemHeightRef.current(i, list[i]), 0);\n    return height;\n  };\n  const totalHeight = useMemo(() => {\n    if (isNumber(itemHeightRef.current)) {\n      return list.length * itemHeightRef.current;\n    }\n    return list.reduce((sum, _, index) => sum + itemHeightRef.current(index, list[index]), 0);\n  }, [list]);\n  const calculateRange = () => {\n    const container = getTargetElement(containerTarget);\n    const wrapper = getTargetElement(wrapperTarget);\n    if (container && wrapper) {\n      const {\n        scrollTop,\n        clientHeight\n      } = container;\n      const offset = getOffset(scrollTop);\n      const visibleCount = getVisibleCount(clientHeight, offset);\n      const start = Math.max(0, offset - overscan);\n      const end = Math.min(list.length, offset + visibleCount + overscan);\n      const offsetTop = getDistanceTop(start);\n      wrapper.style.height = totalHeight - offsetTop + 'px';\n      wrapper.style.marginTop = offsetTop + 'px';\n      setTargetList(list.slice(start, end).map((ele, index) => ({\n        data: ele,\n        index: index + start\n      })));\n    }\n  };\n  useEffect(() => {\n    if (!(size === null || size === void 0 ? void 0 : size.width) || !(size === null || size === void 0 ? void 0 : size.height)) {\n      return;\n    }\n    calculateRange();\n  }, [size === null || size === void 0 ? void 0 : size.width, size === null || size === void 0 ? void 0 : size.height, list]);\n  useEventListener('scroll', e => {\n    if (scrollTriggerByScrollToFunc.current) {\n      scrollTriggerByScrollToFunc.current = false;\n      return;\n    }\n    e.preventDefault();\n    calculateRange();\n  }, {\n    target: containerTarget\n  });\n  const scrollTo = index => {\n    const container = getTargetElement(containerTarget);\n    if (container) {\n      scrollTriggerByScrollToFunc.current = true;\n      container.scrollTop = getDistanceTop(index);\n      calculateRange();\n    }\n  };\n  return [targetList, useMemoizedFn(scrollTo)];\n};\nexport default useVirtualList;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}